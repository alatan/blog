<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>AbstractQueuedSynchronizer详解 - 软件开发学习记录</title><meta name="Description" content="AbstractQueuedSynchronizer详解"><meta property="og:title" content="AbstractQueuedSynchronizer详解" />
<meta property="og:description" content="AbstractQueuedSynchronizer详解" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://moge.fun/abstractqueuedsynchronizer/" />
<meta property="og:image" content="https://moge.fun/logo.png"/>
<meta property="article:published_time" content="2018-04-05T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-04-05T00:00:00+00:00" /><meta property="og:site_name" content="My cool site" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://moge.fun/logo.png"/>

<meta name="twitter:title" content="AbstractQueuedSynchronizer详解"/>
<meta name="twitter:description" content="AbstractQueuedSynchronizer详解"/>
<meta name="application-name" content="Journey to the Life">
<meta name="apple-mobile-web-app-title" content="Journey to the Life"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://moge.fun/abstractqueuedsynchronizer/" /><link rel="prev" href="https://moge.fun/locksupport/" /><link rel="next" href="https://moge.fun/concurrenthashmap/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/lib/fontawesome-free/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" href="/lib/animate/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "AbstractQueuedSynchronizer详解",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/moge.fun\/abstractqueuedsynchronizer\/"
        },"genre": "posts","keywords": "并发编程","wordcount":  1339 ,
        "url": "https:\/\/moge.fun\/abstractqueuedsynchronizer\/","datePublished": "2018-04-05T00:00:00+00:00","dateModified": "2018-04-05T00:00:00+00:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "默哥"
            },"description": "AbstractQueuedSynchronizer详解"
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="软件开发学习记录">软件开发学习记录</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/about/"> 关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="软件开发学习记录">软件开发学习记录</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/about/" title="">关于</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content always-active" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">AbstractQueuedSynchronizer详解</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>默哥</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/java%E5%9F%BA%E7%A1%80/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>Java基础</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2018-04-05">2018-04-05</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;约 1339 字&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;预计阅读 7 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#原理概览">原理概览</a></li>
    <li><a href="#aqs数据结构">AQS数据结构</a>
      <ul>
        <li><a href="#线程两种资源共享方式">线程两种资源共享方式</a></li>
        <li><a href="#属性值的含义">属性值的含义</a></li>
        <li><a href="#waitstatus节点状态">waitStatus（节点状态）</a></li>
      </ul>
    </li>
    <li><a href="#aqs重要方法与reentrantlock的关联">AQS重要方法与ReentrantLock的关联</a>
      <ul>
        <li><a href="#方法">方法</a></li>
        <li><a href="#加锁">加锁：</a></li>
        <li><a href="#解锁">解锁：</a></li>
      </ul>
    </li>
    <li><a href="#通过reentrantlock理解aqs">通过ReentrantLock理解AQS</a>
      <ul>
        <li><a href="#线程加入等待队列">线程加入等待队列</a>
          <ul>
            <li><a href="#加入队列的时机">加入队列的时机</a></li>
            <li><a href="#如何加入队列">如何加入队列</a></li>
            <li><a href="#等待队列中线程出队列时机">等待队列中线程出队列时机</a></li>
            <li><a href="#cancelled状态节点生成">CANCELLED状态节点生成</a></li>
          </ul>
        </li>
        <li><a href="#如何解锁">如何解锁</a></li>
        <li><a href="#中断恢复后的执行流程">中断恢复后的执行流程</a></li>
      </ul>
    </li>
    <li><a href="#abstractqueuedsynchronizer总结">AbstractQueuedSynchronizer总结</a></li>
    <li><a href="#参考文章">参考文章</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><p><figure><a class="lightgallery" href="/images/current/aqs/AQS.png" title="/images/current/aqs/AQS.png" data-thumbnail="/images/current/aqs/AQS.png" data-sub-html="<h2>AQS</h2>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/current/aqs/AQS.png"
            data-srcset="/images/current/aqs/AQS.png, /images/current/aqs/AQS.png 1.5x, /images/current/aqs/AQS.png 2x"
            data-sizes="auto"
            alt="/images/current/aqs/AQS.png" />
    </a><figcaption class="image-caption">AQS</figcaption>
    </figure></p>
<ul>
<li>上图中有颜色的为Method，无颜色的为Attribution。</li>
<li>总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。</li>
<li>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</li>
</ul>
<h2 id="原理概览">原理概览</h2>
<p>AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p>
<blockquote>
<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点(Node)来实现锁的分配。</p>
</blockquote>
<p>AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">state</span><span class="o">;</span><span class="c1">//共享变量，使用volatile修饰保证线程可见性
</span></code></pre></td></tr></table>
</div>
</div><h2 id="aqs数据结构">AQS数据结构</h2>
<p><figure><a class="lightgallery" href="/images/current/aqs/juc-aqs.png" title="/images/current/aqs/juc-aqs.png" data-thumbnail="/images/current/aqs/juc-aqs.png" data-sub-html="<h2>AQS数据结构</h2>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/current/aqs/juc-aqs.png"
            data-srcset="/images/current/aqs/juc-aqs.png, /images/current/aqs/juc-aqs.png 1.5x, /images/current/aqs/juc-aqs.png 2x"
            data-sizes="auto"
            alt="/images/current/aqs/juc-aqs.png" />
    </a><figcaption class="image-caption">AQS数据结构</figcaption>
    </figure></p>
<h3 id="线程两种资源共享方式">线程两种资源共享方式</h3>
<ul>
<li>Share(共享)：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock。</li>
<li>Exclusive(独占)：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：
<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
</li>
</ul>
<p>ReentrantReadWriteLock可以看成是组合式，因为ReentrantReadWriteLock是读写锁允许多个线程同时对某一资源进行读。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护(如获取资源失败入队/唤醒出队等)，AQS已经在上层已经帮我们实现好了。</p>
<h3 id="属性值的含义">属性值的含义</h3>
<ul>
<li>waitStatus	当前节点在队列中的状态</li>
<li>thread	表示处于该节点的线程</li>
<li>prev	前驱指针</li>
<li>predecessor	返回前驱节点，没有的话抛出npe</li>
<li>nextWaiter	指向下一个处于CONDITION状态的节点（由于本篇文章不讲述Condition Queue队列，这个指针不多介绍）</li>
<li>next	后继指针</li>
</ul>
<h3 id="waitstatus节点状态">waitStatus（节点状态）</h3>
<ul>
<li>0，表示当前节点在sync queue中，等待着获取锁。</li>
<li>SIGNAL	为-1，表示线程已经准备好了，就等资源释放了,表示当前节点的后继节点包含的线程需要运行，需要进行unpark操作。</li>
<li>CANCELLED	为1，表示线程获取锁的请求已经取消了</li>
<li>CONDITION	为-2，表示当前节点在等待condition，也就是在condition queue中，节点线程等待唤醒</li>
<li>PROPAGATE	为-3，表示当前场景下后续的acquireShared能够得以执行。</li>
</ul>
<p><figure><a class="lightgallery" href="/images/current/aqs/AQS-EXCLUSIVE.png" title="/images/current/aqs/AQS-EXCLUSIVE.png" data-thumbnail="/images/current/aqs/AQS-EXCLUSIVE.png" data-sub-html="<h2>AQS独占模式加锁</h2>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/current/aqs/AQS-EXCLUSIVE.png"
            data-srcset="/images/current/aqs/AQS-EXCLUSIVE.png, /images/current/aqs/AQS-EXCLUSIVE.png 1.5x, /images/current/aqs/AQS-EXCLUSIVE.png 2x"
            data-sizes="auto"
            alt="/images/current/aqs/AQS-EXCLUSIVE.png" />
    </a><figcaption class="image-caption">AQS独占模式加锁</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="/images/current/aqs/AQS-SHARED.png" title="/images/current/aqs/AQS-SHARED.png" data-thumbnail="/images/current/aqs/AQS-SHARED.png" data-sub-html="<h2>AQS共享模式加锁</h2>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/current/aqs/AQS-SHARED.png"
            data-srcset="/images/current/aqs/AQS-SHARED.png, /images/current/aqs/AQS-SHARED.png 1.5x, /images/current/aqs/AQS-SHARED.png 2x"
            data-sizes="auto"
            alt="/images/current/aqs/AQS-SHARED.png" />
    </a><figcaption class="image-caption">AQS共享模式加锁</figcaption>
    </figure></p>
<h2 id="aqs重要方法与reentrantlock的关联">AQS重要方法与ReentrantLock的关联</h2>
<h3 id="方法">方法</h3>
<p>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法</p>
<ul>
<li>protected boolean isHeldExclusively()	该线程是否正在独占资源。只有用到Condition才需要去实现它。</li>
<li>protected boolean tryAcquire(int arg)	独占方式。arg为获取锁的次数，尝试获取资源，成功则返回True，失败则返回False。</li>
<li>protected boolean tryRelease(int arg)	独占方式。arg为释放锁的次数，尝试释放资源，成功则返回True，失败则返回False。</li>
<li>protected int tryAcquireShared(int arg)	共享方式。arg为获取锁的次数，尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li>protected boolean tryReleaseShared(int arg)	共享方式。arg为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回True，否则返回False。</li>
</ul>
<p>默认情况下，每个方法都抛出 UnsupportedOperationException。 <strong>这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞</strong>。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p>
<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0(即释放锁)为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的(state会累加)，这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>
<p>一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。ReentrantLock是独占锁，所以实现了tryAcquire-tryRelease。</p>
<p>以非公平锁为例，这里主要阐述一下非公平锁与AQS之间方法的关联之处，具体每一处核心方法的作用会在文章后面详细进行阐述。
<figure><a class="lightgallery" href="/images/current/aqs/AQS-ReentrantLock.png" title="/images/current/aqs/AQS-ReentrantLock.png" data-thumbnail="/images/current/aqs/AQS-ReentrantLock.png" data-sub-html="<h2>ReentrantLock加锁流程</h2>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/current/aqs/AQS-ReentrantLock.png"
            data-srcset="/images/current/aqs/AQS-ReentrantLock.png, /images/current/aqs/AQS-ReentrantLock.png 1.5x, /images/current/aqs/AQS-ReentrantLock.png 2x"
            data-sizes="auto"
            alt="/images/current/aqs/AQS-ReentrantLock.png" />
    </a><figcaption class="image-caption">ReentrantLock加锁流程</figcaption>
    </figure></p>
<p>为了帮助大家理解ReentrantLock和AQS之间方法的交互过程，以非公平锁为例，我们将加锁和解锁的交互流程单独拎出来强调一下，以便于对后续内容的理解。
<figure><a class="lightgallery" href="/images/current/aqs/AQS-ReentrantLock-mehtod-1.png" title="/images/current/aqs/AQS-ReentrantLock-mehtod-1.png" data-thumbnail="/images/current/aqs/AQS-ReentrantLock-mehtod-1.png" data-sub-html="<h2>ReentrantLock流程梳理</h2>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/current/aqs/AQS-ReentrantLock-mehtod-1.png"
            data-srcset="/images/current/aqs/AQS-ReentrantLock-mehtod-1.png, /images/current/aqs/AQS-ReentrantLock-mehtod-1.png 1.5x, /images/current/aqs/AQS-ReentrantLock-mehtod-1.png 2x"
            data-sizes="auto"
            alt="/images/current/aqs/AQS-ReentrantLock-mehtod-1.png" />
    </a><figcaption class="image-caption">ReentrantLock流程梳理</figcaption>
    </figure></p>
<h3 id="加锁">加锁：</h3>
<ul>
<li>通过ReentrantLock的加锁方法Lock进行加锁操作。</li>
<li>会调用到内部类Sync的Lock方法，由于Sync#lock是抽象方法，根据ReentrantLock初始化选择的公平锁和非公平锁，执行相关内部类的Lock方法，本质上都会执行AQS的Acquire方法。</li>
<li>AQS的Acquire方法会执行tryAcquire方法，但是由于tryAcquire需要自定义同步器实现，因此执行了ReentrantLock中的tryAcquire方法，由于ReentrantLock是通过公平锁和非公平锁内部类实现的tryAcquire方法，因此会根据锁类型不同，执行不同的tryAcquire。</li>
<li>tryAcquire是获取锁逻辑，获取失败后，会执行框架AQS的后续逻辑，跟ReentrantLock自定义同步器无关。</li>
</ul>
<h3 id="解锁">解锁：</h3>
<ul>
<li>通过ReentrantLock的解锁方法Unlock进行解锁。</li>
<li>Unlock会调用内部类Sync的Release方法，该方法继承于AQS。</li>
<li>Release中会调用tryRelease方法，tryRelease需要自定义同步器实现，tryRelease只在ReentrantLock中的Sync实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。</li>
<li>释放成功后，所有处理由AQS框架完成，与自定义同步器无关。</li>
</ul>
<p>通过上面的描述，大概可以总结出ReentrantLock加锁解锁时API层核心方法的映射关系。
<figure><a class="lightgallery" href="/images/current/aqs/AQS-ReentrantLock-mehtod-2.png" title="/images/current/aqs/AQS-ReentrantLock-mehtod-2.png" data-thumbnail="/images/current/aqs/AQS-ReentrantLock-mehtod-2.png" data-sub-html="<h2>ReentrantLock映射关系</h2>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/current/aqs/AQS-ReentrantLock-mehtod-2.png"
            data-srcset="/images/current/aqs/AQS-ReentrantLock-mehtod-2.png, /images/current/aqs/AQS-ReentrantLock-mehtod-2.png 1.5x, /images/current/aqs/AQS-ReentrantLock-mehtod-2.png 2x"
            data-sizes="auto"
            alt="/images/current/aqs/AQS-ReentrantLock-mehtod-2.png" />
    </a><figcaption class="image-caption">ReentrantLock映射关系</figcaption>
    </figure></p>
<h2 id="通过reentrantlock理解aqs">通过ReentrantLock理解AQS</h2>
<p>ReentrantLock中公平锁和非公平锁在底层是相同的，这里以非公平锁为例进行分析。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// java.util.concurrent.locks.ReentrantLock
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">NonfairSync</span> <span class="kd">extends</span> <span class="n">Sync</span> <span class="o">{</span>
	<span class="o">...</span>
	<span class="kd">final</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">1</span><span class="o">))</span>
			<span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">());</span>
		<span class="k">else</span>
			<span class="n">acquire</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
	<span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span>

<span class="c1">// java.util.concurrent.locks.AbstractQueuedSynchronizer
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">acquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(!</span><span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">acquireQueued</span><span class="o">(</span><span class="n">addWaiter</span><span class="o">(</span><span class="n">Node</span><span class="o">.</span><span class="na">EXCLUSIVE</span><span class="o">),</span> <span class="n">arg</span><span class="o">))</span>
		<span class="n">selfInterrupt</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// java.util.concurrent.locks.AbstractQueuedSynchronizer
</span><span class="c1"></span><span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">throw</span> <span class="k">new</span> <span class="n">UnsupportedOperationException</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看出，这里只是AQS的简单实现，具体获取锁的实现方法是由各自的公平锁和非公平锁单独实现的（以ReentrantLock为例）。如果该方法返回了True，则说明当前线程获取锁成功，就不用往后执行了；如果获取失败，就需要加入到等待队列中。下面会详细解释线程是何时以及怎样被加入进等待队列中的。</p>
<h3 id="线程加入等待队列">线程加入等待队列</h3>
<h4 id="加入队列的时机">加入队列的时机</h4>
<p>当执行Acquire(1)时，会通过tryAcquire获取锁。在这种情况下，如果获取锁失败，就会调用addWaiter加入到等待队列中去。</p>
<h4 id="如何加入队列">如何加入队列</h4>
<p>获取锁失败后，会执行addWaiter(Node.EXCLUSIVE)加入等待队列，具体实现方法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// java.util.concurrent.locks.AbstractQueuedSynchronizer
</span><span class="c1"></span>
<span class="kd">private</span> <span class="n">Node</span> <span class="nf">addWaiter</span><span class="o">(</span><span class="n">Node</span> <span class="n">mode</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">(),</span> <span class="n">mode</span><span class="o">);</span>
	<span class="c1">// Try the fast path of enq; backup to full enq on failure
</span><span class="c1"></span>	<span class="n">Node</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">pred</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pred</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetTail</span><span class="o">(</span><span class="n">pred</span><span class="o">,</span> <span class="n">node</span><span class="o">))</span> <span class="o">{</span>
			<span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
			<span class="k">return</span> <span class="n">node</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>
	<span class="n">enq</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
	<span class="k">return</span> <span class="n">node</span><span class="o">;</span>
<span class="o">}</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">compareAndSetTail</span><span class="o">(</span><span class="n">Node</span> <span class="n">expect</span><span class="o">,</span> <span class="n">Node</span> <span class="n">update</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">tailOffset</span><span class="o">,</span> <span class="n">expect</span><span class="o">,</span> <span class="n">update</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>主要的流程如下：</p>
<ol>
<li>通过当前的线程和锁模式新建一个节点。</li>
<li>Pred指针指向尾节点Tail。</li>
<li>将New中Node的Prev指针指向Pred。</li>
<li>通过compareAndSetTail方法，完成尾节点的设置。这个方法主要是对tailOffset和Expect进行比较，如果tailOffset的Node和Expect的Node地址是相同的，那么设置Tail的值为Update的值。</li>
<li>如果Pred指针是Null（说明等待队列中没有元素），或者当前Pred指针和Tail指向的位置不同（说明被别的线程已经修改），就需要看一下Enq的方法。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// java.util.concurrent.locks.AbstractQueuedSynchronizer
</span><span class="c1"></span><span class="kd">private</span> <span class="n">Node</span> <span class="nf">enq</span><span class="o">(</span><span class="kd">final</span> <span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
		<span class="n">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Must initialize
</span><span class="c1"></span>			<span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetHead</span><span class="o">(</span><span class="k">new</span> <span class="n">Node</span><span class="o">()))</span>
				<span class="n">tail</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
		<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
			<span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetTail</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">node</span><span class="o">))</span> <span class="o">{</span>
				<span class="n">t</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
				<span class="k">return</span> <span class="n">t</span><span class="o">;</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果没有被初始化，需要进行初始化一个头结点出来。但请注意，初始化的头结点并不是当前线程节点，而是调用了无参构造函数的节点。如果经历了初始化或者并发导致队列中有元素，则与之前的方法相同。其实，addWaiter就是一个在双端链表添加尾节点的操作，需要注意的是，双端链表的头结点是一个无参构造函数的头结点。</p>
<p>总结一下，线程获取锁的时候，过程大体如下：</p>
<ol>
<li>当没有线程获取到锁时，线程1获取锁成功。</li>
<li>线程2申请锁，但是锁被线程1占有。</li>
<li>如果再有线程要获取锁，依次在队列中往后排队即可。</li>
</ol>
<h4 id="等待队列中线程出队列时机">等待队列中线程出队列时机</h4>
<p>回到最初的源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// java.util.concurrent.locks.AbstractQueuedSynchronizer
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">acquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(!</span><span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">acquireQueued</span><span class="o">(</span><span class="n">addWaiter</span><span class="o">(</span><span class="n">Node</span><span class="o">.</span><span class="na">EXCLUSIVE</span><span class="o">),</span> <span class="n">arg</span><span class="o">))</span>
		<span class="n">selfInterrupt</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上文解释了addWaiter方法，这个方法其实就是把对应的线程以Node的数据结构形式加入到双端队列里，返回的是一个包含该线程的Node。</p>
<p><strong>而这个Node会作为参数，进入到acquireQueued方法中。acquireQueued方法可以对排队中的线程进行“获锁”操作。</strong></p>
<p><strong>总的来说，一个线程获取锁失败了，被放入等待队列，acquireQueued会把放入队列中的线程不断去获取锁，直到获取成功或者不再需要获取（中断）。</strong></p>
<p>下面我们从“何时出队列？”和“如何出队列？”两个方向来分析一下acquireQueued源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// java.util.concurrent.locks.AbstractQueuedSynchronizer
</span><span class="c1"></span><span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">acquireQueued</span><span class="o">(</span><span class="kd">final</span> <span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">// 标记是否成功拿到资源
</span><span class="c1"></span>	<span class="kt">boolean</span> <span class="n">failed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
	<span class="k">try</span> <span class="o">{</span>
		<span class="c1">// 标记等待过程中是否中断过
</span><span class="c1"></span>		<span class="kt">boolean</span> <span class="n">interrupted</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
		<span class="c1">// 开始自旋，要么获取锁，要么中断
</span><span class="c1"></span>		<span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
			<span class="c1">// 获取当前节点的前驱节点
</span><span class="c1"></span>			<span class="kd">final</span> <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">predecessor</span><span class="o">();</span>
			<span class="c1">// 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点）
</span><span class="c1"></span>			<span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">head</span> <span class="o">&amp;&amp;</span> <span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
				<span class="c1">// 获取锁成功，头指针移动到当前node
</span><span class="c1"></span>				<span class="n">setHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
				<span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// help GC
</span><span class="c1"></span>				<span class="n">failed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
				<span class="k">return</span> <span class="n">interrupted</span><span class="o">;</span>
			<span class="o">}</span>
			<span class="c1">// 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者是p不为头结点，这个时候就要判断当前node是否要被阻塞（被阻塞条件：前驱节点的waitStatus为-1），防止无限循环浪费资源。具体两个方法下面细细分析
</span><span class="c1"></span>			<span class="k">if</span> <span class="o">(</span><span class="n">shouldParkAfterFailedAcquire</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">parkAndCheckInterrupt</span><span class="o">())</span>
				<span class="n">interrupted</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">failed</span><span class="o">)</span>
			<span class="n">cancelAcquire</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注：setHead方法是把当前节点置为虚节点，但并没有修改waitStatus，因为它是一直需要用的数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// java.util.concurrent.locks.AbstractQueuedSynchronizer
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">setHead</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
	<span class="n">node</span><span class="o">.</span><span class="na">thread</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
	<span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// java.util.concurrent.locks.AbstractQueuedSynchronizer
</span><span class="c1">// 靠前驱节点判断当前线程是否应该被阻塞
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">shouldParkAfterFailedAcquire</span><span class="o">(</span><span class="n">Node</span> <span class="n">pred</span><span class="o">,</span> <span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">// 获取头结点的节点状态
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="na">waitStatus</span><span class="o">;</span>
	<span class="c1">// 说明头结点处于唤醒状态
</span><span class="c1"></span>	<span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="na">SIGNAL</span><span class="o">)</span>
		<span class="k">return</span> <span class="kc">true</span><span class="o">;</span> 
	<span class="c1">// 通过枚举值我们知道waitStatus&gt;0是取消状态
</span><span class="c1"></span>	<span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">do</span> <span class="o">{</span>
			<span class="c1">// 循环向前查找取消节点，把取消节点从队列中剔除
</span><span class="c1"></span>			<span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
		<span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">pred</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">);</span>
		<span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
	<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
		<span class="c1">// 设置前任节点等待状态为SIGNAL
</span><span class="c1"></span>		<span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">pred</span><span class="o">,</span> <span class="n">ws</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">SIGNAL</span><span class="o">);</span>
	<span class="o">}</span>
	<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>parkAndCheckInterrupt主要用于挂起当前线程，阻塞调用栈，返回当前线程的中断状态。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// java.util.concurrent.locks.AbstractQueuedSynchronizer
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">parkAndCheckInterrupt</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">LockSupport</span><span class="o">.</span><span class="na">park</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述方法的流程图如下：
<figure><a class="lightgallery" href="/images/current/aqs/AQS-Lock-procedure-1.png" title="/images/current/aqs/AQS-Lock-procedure-1.png" data-thumbnail="/images/current/aqs/AQS-Lock-procedure-1.png" data-sub-html="<h2>AQS加锁流程1</h2>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/current/aqs/AQS-Lock-procedure-1.png"
            data-srcset="/images/current/aqs/AQS-Lock-procedure-1.png, /images/current/aqs/AQS-Lock-procedure-1.png 1.5x, /images/current/aqs/AQS-Lock-procedure-1.png 2x"
            data-sizes="auto"
            alt="/images/current/aqs/AQS-Lock-procedure-1.png" />
    </a><figcaption class="image-caption">AQS加锁流程1</figcaption>
    </figure></p>
<p><strong>从上图可以看出，跳出当前循环的条件是当“前置节点是头结点，且当前线程获取锁成功”。为了防止因死循环导致CPU资源被浪费，我们会判断前置节点的状态来决定是否要将当前线程挂起，具体挂起流程用流程图表示如下（shouldParkAfterFailedAcquire流程）</strong>：</p>
<p><figure><a class="lightgallery" href="/images/current/aqs/AQS-Lock-procedure-2.png" title="/images/current/aqs/AQS-Lock-procedure-2.png" data-thumbnail="/images/current/aqs/AQS-Lock-procedure-2.png" data-sub-html="<h2>AQS加锁流程2</h2>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/current/aqs/AQS-Lock-procedure-2.png"
            data-srcset="/images/current/aqs/AQS-Lock-procedure-2.png, /images/current/aqs/AQS-Lock-procedure-2.png 1.5x, /images/current/aqs/AQS-Lock-procedure-2.png 2x"
            data-sizes="auto"
            alt="/images/current/aqs/AQS-Lock-procedure-2.png" />
    </a><figcaption class="image-caption">AQS加锁流程2</figcaption>
    </figure></p>
<p>从队列中释放节点的疑虑打消了，那么又有新问题了：</p>
<ul>
<li>shouldParkAfterFailedAcquire中取消节点是怎么生成的呢？什么时候会把一个节点的waitStatus设置为-1？</li>
<li>是在什么时间释放节点通知到被挂起的线程呢</li>
</ul>
<h4 id="cancelled状态节点生成">CANCELLED状态节点生成</h4>
<p>acquireQueued方法中的Finally代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// java.util.concurrent.locks.AbstractQueuedSynchronizer
</span><span class="c1"></span><span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">acquireQueued</span><span class="o">(</span><span class="kd">final</span> <span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">boolean</span> <span class="n">failed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
	<span class="k">try</span> <span class="o">{</span>
    <span class="o">...</span>
		<span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
			<span class="kd">final</span> <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">predecessor</span><span class="o">();</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">head</span> <span class="o">&amp;&amp;</span> <span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
				<span class="o">...</span>
				<span class="n">failed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">...</span>
			<span class="o">}</span>
			<span class="o">...</span>
	<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">failed</span><span class="o">)</span>
			<span class="n">cancelAcquire</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
		<span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>通过cancelAcquire方法，将Node的状态标记为CANCELLED。接下来，我们逐行来分析这个方法的原理：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// java.util.concurrent.locks.AbstractQueuedSynchronizer
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">cancelAcquire</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// 将无效节点过滤
</span><span class="c1"></span>	<span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
		<span class="k">return</span><span class="o">;</span>
  <span class="c1">// 设置该节点不关联任何线程，也就是虚节点
</span><span class="c1"></span>	<span class="n">node</span><span class="o">.</span><span class="na">thread</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
	<span class="n">Node</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
  <span class="c1">// 通过前驱节点，跳过取消状态的node
</span><span class="c1"></span>	<span class="k">while</span> <span class="o">(</span><span class="n">pred</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span>
		<span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
  <span class="c1">// 获取过滤后的前驱节点的后继节点
</span><span class="c1"></span>	<span class="n">Node</span> <span class="n">predNext</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
  <span class="c1">// 把当前node的状态设置为CANCELLED
</span><span class="c1"></span>	<span class="n">node</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="na">CANCELLED</span><span class="o">;</span>
  <span class="c1">// 如果当前节点是尾节点，将从后往前的第一个非取消状态的节点设置为尾节点
</span><span class="c1"></span>  <span class="c1">// 更新失败的话，则进入else，如果更新成功，将tail的后继节点设置为null
</span><span class="c1"></span>	<span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">tail</span> <span class="o">&amp;&amp;</span> <span class="n">compareAndSetTail</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">pred</span><span class="o">))</span> <span class="o">{</span>
		<span class="n">compareAndSetNext</span><span class="o">(</span><span class="n">pred</span><span class="o">,</span> <span class="n">predNext</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
	<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">ws</span><span class="o">;</span>
    <span class="c1">// 如果当前节点不是head的后继节点，1:判断当前节点前驱节点的是否为SIGNAL，2:如果不是，则把前驱节点设置为SINGAL看是否成功
</span><span class="c1"></span>    <span class="c1">// 如果1和2中有一个为true，再判断当前节点的线程是否为null
</span><span class="c1"></span>    <span class="c1">// 如果上述条件都满足，把当前节点的前驱节点的后继指针指向当前节点的后继节点
</span><span class="c1"></span>		<span class="k">if</span> <span class="o">(</span><span class="n">pred</span> <span class="o">!=</span> <span class="n">head</span> <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="n">ws</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="na">waitStatus</span><span class="o">)</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="na">SIGNAL</span> <span class="o">||</span> <span class="o">(</span><span class="n">ws</span> <span class="o">&lt;=</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">pred</span><span class="o">,</span> <span class="n">ws</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">SIGNAL</span><span class="o">)))</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="o">.</span><span class="na">thread</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">Node</span> <span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">next</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">next</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&lt;=</span> <span class="n">0</span><span class="o">)</span>
				<span class="n">compareAndSetNext</span><span class="o">(</span><span class="n">pred</span><span class="o">,</span> <span class="n">predNext</span><span class="o">,</span> <span class="n">next</span><span class="o">);</span>
		<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="c1">// 如果当前节点是head的后继节点，或者上述条件不满足，那就唤醒当前节点的后继节点
</span><span class="c1"></span>			<span class="n">unparkSuccessor</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
		<span class="o">}</span>
		<span class="n">node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span> <span class="c1">// help GC
</span><span class="c1"></span>	<span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当前的流程：</p>
<ul>
<li>获取当前节点的前驱节点，如果前驱节点的状态是CANCELLED，那就一直往前遍历，找到第一个waitStatus &lt;= 0的节点，将找到的Pred节点和当前Node关联，将当前Node设置为CANCELLED。</li>
<li>根据当前节点的位置，考虑以下三种情况：</li>
</ul>
<ol>
<li>当前节点是尾节点。</li>
<li>当前节点是Head的后继节点。</li>
<li>当前节点不是Head的后继节点，也不是尾节点。</li>
</ol>
<h3 id="如何解锁">如何解锁</h3>
<p>我们已经剖析了加锁过程中的基本流程，接下来再对解锁的基本流程进行分析。由于ReentrantLock在解锁的时候，并不区分公平锁和非公平锁，所以我们直接看解锁的源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// java.util.concurrent.locks.ReentrantLock
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span>
	<span class="n">sync</span><span class="o">.</span><span class="na">release</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// java.util.concurrent.locks.AbstractQueuedSynchronizer
</span><span class="c1">// 可以看到，本质释放锁的地方，是通过框架来完成的。
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">release</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">tryRelease</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
		<span class="n">Node</span> <span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span>
			<span class="n">unparkSuccessor</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
		<span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">//在ReentrantLock里面的公平锁和非公平锁的父类Sync定义了可重入锁的释放锁机制。
</span><span class="c1">// java.util.concurrent.locks.ReentrantLock.Sync
</span><span class="c1">// 方法返回当前锁是不是没有被线程持有
</span><span class="c1"></span><span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryRelease</span><span class="o">(</span><span class="kt">int</span> <span class="n">releases</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">// 减少可重入次数
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">()</span> <span class="o">-</span> <span class="n">releases</span><span class="o">;</span>
	<span class="c1">// 当前线程不是持有锁的线程，抛出异常
</span><span class="c1"></span>	<span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">()</span> <span class="o">!=</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span>
		<span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalMonitorStateException</span><span class="o">();</span>
	<span class="kt">boolean</span> <span class="n">free</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
	<span class="c1">// 如果持有线程全部释放，将当前独占锁所有线程设置为null，并更新state
</span><span class="c1"></span>	<span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">free</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
		<span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
	<span class="o">}</span>
	<span class="n">setState</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
	<span class="k">return</span> <span class="n">free</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// java.util.concurrent.locks.AbstractQueuedSynchronizer
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">release</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">// 上边自定义的tryRelease如果返回true，说明该锁没有被任何线程持有
</span><span class="c1"></span>	<span class="k">if</span> <span class="o">(</span><span class="n">tryRelease</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
		<span class="c1">// 获取头结点
</span><span class="c1"></span>		<span class="n">Node</span> <span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
		<span class="c1">// 头结点不为空并且头结点的waitStatus不是初始化节点情况，解除线程挂起状态
</span><span class="c1"></span>		<span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span>
			<span class="n">unparkSuccessor</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
		<span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">//再看一下unparkSuccessor方法
</span><span class="c1">// java.util.concurrent.locks.AbstractQueuedSynchronizer
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">unparkSuccessor</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">// 获取头结点waitStatus
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">waitStatus</span><span class="o">;</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span>
		<span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">ws</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span>
	<span class="c1">// 获取当前节点的下一个节点
</span><span class="c1"></span>	<span class="n">Node</span> <span class="n">s</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
	<span class="c1">// 如果下个节点是null或者下个节点被cancelled，就找到队列最开始的非cancelled的节点
</span><span class="c1"></span>	<span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">s</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
		<span class="c1">// 就从尾部节点开始找，到队首，找到队列第一个waitStatus&lt;0的节点。
</span><span class="c1"></span>		<span class="k">for</span> <span class="o">(</span><span class="n">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span> <span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">node</span><span class="o">;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">prev</span><span class="o">)</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&lt;=</span> <span class="n">0</span><span class="o">)</span>
				<span class="n">s</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="c1">// 如果当前节点的下个节点不为空，而且状态&lt;=0，就把当前节点unpark
</span><span class="c1"></span>	<span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
		<span class="n">LockSupport</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">thread</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 为什么要从后往前找第一个非Cancelled的节点呢？原因如下。
</span><span class="c1">// 之前的addWaiter方法：
</span><span class="c1">// java.util.concurrent.locks.AbstractQueuedSynchronizer
</span><span class="c1"></span><span class="kd">private</span> <span class="n">Node</span> <span class="nf">addWaiter</span><span class="o">(</span><span class="n">Node</span> <span class="n">mode</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">(),</span> <span class="n">mode</span><span class="o">);</span>
	<span class="c1">// Try the fast path of enq; backup to full enq on failure
</span><span class="c1"></span>	<span class="n">Node</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">pred</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pred</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetTail</span><span class="o">(</span><span class="n">pred</span><span class="o">,</span> <span class="n">node</span><span class="o">))</span> <span class="o">{</span>
			<span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
			<span class="k">return</span> <span class="n">node</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>
	<span class="n">enq</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
	<span class="k">return</span> <span class="n">node</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们从这里可以看到，节点入队并不是原子操作，也就是说，node.prev = pred; compareAndSetTail(pred, node) 这两个地方可以看作Tail入队的原子操作，但是此时pred.next = node;还没执行，如果这个时候执行了unparkSuccessor方法，就没办法从前往后找了，所以需要从后往前找。还有一点原因，在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的Node。</p>
<p>综上所述，如果是从前往后找，由于极端情况下入队的非原子操作和CANCELLED节点产生过程中断开Next指针的操作，可能会导致无法遍历所有的节点。所以，唤醒对应的线程后，对应的线程就会继续往下执行。继续执行acquireQueued方法以后，中断如何处理？</p>
<h3 id="中断恢复后的执行流程">中断恢复后的执行流程</h3>
<p>唤醒后，会执行return Thread.interrupted();，这个函数返回的是当前执行线程的中断状态，并清除。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// java.util.concurrent.locks.AbstractQueuedSynchronizer
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">parkAndCheckInterrupt</span><span class="o">()</span> <span class="o">{</span>
	<span class="n">LockSupport</span><span class="o">.</span><span class="na">park</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
	<span class="k">return</span> <span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>再回到acquireQueued代码，当parkAndCheckInterrupt返回True或者False的时候，interrupted的值不同，但都会执行下次循环。如果这个时候获取锁成功，就会把当前interrupted返回。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// java.util.concurrent.locks.AbstractQueuedSynchronizer
</span><span class="c1"></span><span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">acquireQueued</span><span class="o">(</span><span class="kd">final</span> <span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">boolean</span> <span class="n">failed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
	<span class="k">try</span> <span class="o">{</span>
		<span class="kt">boolean</span> <span class="n">interrupted</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
		<span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
			<span class="kd">final</span> <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">predecessor</span><span class="o">();</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">head</span> <span class="o">&amp;&amp;</span> <span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
				<span class="n">setHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
				<span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// help GC
</span><span class="c1"></span>				<span class="n">failed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
				<span class="k">return</span> <span class="n">interrupted</span><span class="o">;</span>
			<span class="o">}</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">shouldParkAfterFailedAcquire</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">parkAndCheckInterrupt</span><span class="o">())</span>
				<span class="n">interrupted</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
			<span class="o">}</span>
	<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">failed</span><span class="o">)</span>
			<span class="n">cancelAcquire</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果acquireQueued为True，就会执行selfInterrupt方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// java.util.concurrent.locks.AbstractQueuedSynchronizer
</span><span class="c1"></span><span class="kd">static</span> <span class="kt">void</span> <span class="nf">selfInterrupt</span><span class="o">()</span> <span class="o">{</span>
	<span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">interrupt</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>该方法其实是为了中断线程。但为什么获取了锁以后还要中断线程呢？这部分属于Java提供的协作式中断知识内容，感兴趣同学可以查阅一下。这里简单介绍一下：</p>
<ol>
<li>当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们通过Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为False），并记录下来，如果发现该线程被中断过，就再中断一次。</li>
<li>线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。</li>
</ol>
<h2 id="abstractqueuedsynchronizer总结">AbstractQueuedSynchronizer总结</h2>
<p>对于AbstractQueuedSynchronizer的分析，最核心的就是sync queue的分析。</p>
<ul>
<li>每一个结点都是由前一个结点唤醒</li>
<li>当结点发现前驱结点是head并且尝试获取成功，则会轮到该线程运行。</li>
<li>condition queue中的结点向sync queue中转移是通过条件的signal()操作完成的。</li>
<li>当结点的状态为SIGNAL时，表示后面的结点需要运行。</li>
</ul>
<h2 id="参考文章">参考文章</h2>
<p><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html" title="从ReentrantLock的实现看AQS的原理及应用" target="_blank" rel="noopener noreffer ">从ReentrantLock的实现看AQS的原理及应用</a></p>
<p><a href="https://www.pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html" title="锁核心类AQS详解" target="_blank" rel="noopener noreffer ">锁核心类AQS详解</a></p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2018-04-05</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://moge.fun/abstractqueuedsynchronizer/" data-title="AbstractQueuedSynchronizer详解"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/locksupport/" class="prev" rel="prev" title="LockSupport详解"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>LockSupport详解</a>
            <a href="/concurrenthashmap/" class="next" rel="next" title="ConcurrentHashMap详解">ConcurrentHashMap详解<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
<div id="comments"><div id="utterances" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://utteranc.es/">utterances</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.69.1">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2015 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">默哥</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span><span class="icp-splitter">&nbsp;|&nbsp;</span><br class="icp-br"/>
                    <span class="icp">豫ICP备2021012209号-1</span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/lightgallery/css/lightgallery-bundle.min.css"><link rel="stylesheet" href="/lib/katex/katex.min.css"><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.stemmer.support.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.zh.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lightgallery.min.js"></script><script type="text/javascript" src="/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js"></script><script type="text/javascript" src="/lib/lightgallery/plugins/zoom/lg-zoom.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/sharer/sharer.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/contrib/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/contrib/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{"utterances":{"darkTheme":"github-dark","issueTerm":"pathname","label":"","lightTheme":"github-light","repo":"alatan/BlogDiscuss"}},"lightgallery":true,"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":5,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
