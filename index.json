[{"categories":["微服务"],"content":"微服务最佳实践方案","date":"2020-03-15","objectID":"/springcloudalibaba/","tags":["SpringCloud"],"title":"微服务方案SpringCloudAlibaba","uri":"/springcloudalibaba/"},{"categories":["微服务"],"content":"Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案 ","date":"2020-03-15","objectID":"/springcloudalibaba/:0:0","tags":["SpringCloud"],"title":"微服务方案SpringCloudAlibaba","uri":"/springcloudalibaba/"},{"categories":["微服务"],"content":"组件 Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。 Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。 ","date":"2020-03-15","objectID":"/springcloudalibaba/:0:1","tags":["SpringCloud"],"title":"微服务方案SpringCloudAlibaba","uri":"/springcloudalibaba/"},{"categories":["微服务"],"content":"微服务最佳实践 Spring Cloud - Gateway API网关 Spring Cloud - Ribbon 实现负载均衡 Spring Cloud - Feign 实现远程调用 Spring Cloud - Sleuth 实现调用链监控 Spring Cloud Alibaba - Nacos 实现注册中心 Spring Cloud Alibaba - Nacos 实现配置中心 Spring Cloud Alibaba - Sentinel 实现服务容错 Spring Cloud Alibaba - Seata 实现分布式事务 ","date":"2020-03-15","objectID":"/springcloudalibaba/:0:2","tags":["SpringCloud"],"title":"微服务方案SpringCloudAlibaba","uri":"/springcloudalibaba/"},{"categories":["分布式"],"content":"分布式基础介绍","date":"2020-03-10","objectID":"/distributed/","tags":["分布式"],"title":"分布式介绍","uri":"/distributed/"},{"categories":["分布式"],"content":"分布式理论基础 CAP 理论是分布式中基础理论，有三个重要指标：一致性、可用性、分区容错性。 一致性（Consistency） 可用性（Availability） 分区容错性（Partition Tolerance） ","date":"2020-03-10","objectID":"/distributed/:0:1","tags":["分布式"],"title":"分布式介绍","uri":"/distributed/"},{"categories":["知识体系"],"content":"Java架构演变历史","date":"2020-03-01","objectID":"/javaarchhistory/","tags":["大纲"],"title":"Java架构演变历史","uri":"/javaarchhistory/"},{"categories":["知识体系"],"content":"Java网站架构演变过程，大致分为5个阶段，分别为单体架构、集群架构、分布式架构、SOA架构和微服务架构。 ","date":"2020-03-01","objectID":"/javaarchhistory/:0:0","tags":["大纲"],"title":"Java架构演变历史","uri":"/javaarchhistory/"},{"categories":["知识体系"],"content":"单体架构 应用、数据库、文件都部署在一台机器上。简单来讲其实就是我们熟知的SSM架构(Spring+SpringMVC+MyBatis)，把所有的业务模块都放在一个应用中开发，这里面又衍生出三层架构，即表示层、业务逻辑层和数据库访问层，虽然在软件设计中划分了经典的三层模型，但是对业务场景没有划分，一个典型的单体应用就是将所有的业务场景的表示层、业务逻辑层和数据访问层放在一个工程项目中，最终经过编译、打包，部署在一台服务器上。 单体架构优点 部署简单: 由于是完整的结构体，可以直接部署在一个服务器上即可。 技术单一: 项目不需要复杂的技术栈，往往一套熟悉的技术栈就可以完成开发。 用人成本低: 单个程序员可以完成业务接口到数据库的整个流程。 单体架构缺点 系统启动慢： 一个进程包含了所有的业务逻辑，涉及到的启动模块过多，导致系统的启动、重启时间周期过长; 系统错误隔离性差、可用性差：任何一个模块的错误均可能造成整个系统的宕机; 可伸缩性差：系统的扩容只能只对这个应用进行扩容，不能做到对某个功能点进行扩容; 线上问题修复周期长：任何一个线上问题修复需要对整个应用系统进行全面升级。 ","date":"2020-03-01","objectID":"/javaarchhistory/:0:1","tags":["大纲"],"title":"Java架构演变历史","uri":"/javaarchhistory/"},{"categories":["知识体系"],"content":"集群架构 不同服务器部署同一套应用程序对外提供服务，实现服务的负载均衡或者互备(热备，主从)。同一种组件的多个实例，形成逻辑上的整体。单个节点可以提供完整服务，集群是物理形态。 集群架构相关技术点 应用和数据分离(大量用户高并发的访问导致系统性能越来越差，数据存储空间开始出现不足) 缓存的使用(QPS持续提高，为了降低接口访问时间、提高服务性能和并发，根据二八定律可以将80%的数据缓存) 负载均衡器的代理服务器 数据库读写分离 反向代理和CDN加速 ","date":"2020-03-01","objectID":"/javaarchhistory/:0:2","tags":["大纲"],"title":"Java架构演变历史","uri":"/javaarchhistory/"},{"categories":["知识体系"],"content":"分布式架构 服务的不同模块部署在不同的机器上，单个节点不能提供完整服务，需要多节点协调提供服务(相同组件部署在不同节点，节点间通过交互信息协作提供服务)，分布式强调的是工作方式。 分布式相关技术点 业务分库分表 NoSQL和搜索引擎对可伸缩的分布式特性具有更好的支持，应用服务器通过一个统一的数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。 业务模块拆分成子项目 ","date":"2020-03-01","objectID":"/javaarchhistory/:0:3","tags":["大纲"],"title":"Java架构演变历史","uri":"/javaarchhistory/"},{"categories":["知识体系"],"content":"SOA架构 面向服务的设计架构，其中包含多个服务，服务之间通过相互依赖最终提供一系列的功能。一个服务通常以独立的形式存在于操作系统进程中。各个服务之间通过网络调用。 中心化实现：ESB(企业服务总线)，各服务通过ESB进行交互，解决异构系统之间的连通性，通过协议转换，消息解析，消息路由把服务提供者的数据传送到服务消费者。 去中心化实现：微服务 ","date":"2020-03-01","objectID":"/javaarchhistory/:0:4","tags":["大纲"],"title":"Java架构演变历史","uri":"/javaarchhistory/"},{"categories":["知识体系"],"content":"微服务架构 在SOA上做的升华，微服务架构强调业务需要彻底组件化和服务化，原有的单个业务系统会拆分为多个可独立开发，设计，运行的小应用。这些小应用通过服务完成交互和集成。 ","date":"2020-03-01","objectID":"/javaarchhistory/:0:5","tags":["大纲"],"title":"Java架构演变历史","uri":"/javaarchhistory/"},{"categories":["知识体系"],"content":"Java知识大纲","date":"2020-01-01","objectID":"/javaoutline/","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"基础 ","date":"2020-01-01","objectID":"/javaoutline/:1:0","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"数据结构与算法 ","date":"2020-01-01","objectID":"/javaoutline/:1:1","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"操作系统 ","date":"2020-01-01","objectID":"/javaoutline/:1:2","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"网络基础 ","date":"2020-01-01","objectID":"/javaoutline/:1:3","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"数据库基础 ","date":"2020-01-01","objectID":"/javaoutline/:1:4","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"编译原理 ","date":"2020-01-01","objectID":"/javaoutline/:1:5","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"Java ","date":"2020-01-01","objectID":"/javaoutline/:2:0","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"Java基础 ","date":"2020-01-01","objectID":"/javaoutline/:2:1","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"并发编程 ","date":"2020-01-01","objectID":"/javaoutline/:2:2","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"JVM ","date":"2020-01-01","objectID":"/javaoutline/:2:3","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"性能优化 性能指标体系 JVM调优 Tomcat调优 MySQL调优 ","date":"2020-01-01","objectID":"/javaoutline/:2:4","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"故障排除 ","date":"2020-01-01","objectID":"/javaoutline/:2:5","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"最佳实践 ","date":"2020-01-01","objectID":"/javaoutline/:3:0","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"重构 ","date":"2020-01-01","objectID":"/javaoutline/:3:1","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"设计模式 ","date":"2020-01-01","objectID":"/javaoutline/:3:2","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"开发框架 Spring体系 MyBatis ","date":"2020-01-01","objectID":"/javaoutline/:3:3","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"常见业务 支付幂等性 减库存 秒杀 分布式锁 redis实现的分布式锁。 应该保证互斥性（在任何时候只有一个客户端持有锁。使用setnx）。 不能死锁（设置过期时间）。 保证上锁和解锁是同一个客户端（设置不同的value值）。 业务时间太长。导致锁过期（设置看门狗。自动续锁）。 锁的重入性（使用redis的hset）。 分布式事务 分布式缓存 ","date":"2020-01-01","objectID":"/javaoutline/:3:4","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"中间价 ","date":"2020-01-01","objectID":"/javaoutline/:4:0","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"消息队列 ","date":"2020-01-01","objectID":"/javaoutline/:4:1","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"缓存 本地缓存 分布式缓存 ","date":"2020-01-01","objectID":"/javaoutline/:4:2","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"ELK ","date":"2020-01-01","objectID":"/javaoutline/:4:3","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"数据库 分库分表 数据同步 数据库连接池 ","date":"2020-01-01","objectID":"/javaoutline/:4:4","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"分布式 分布式架构原理 分布式架构策略 分布式中间件 分布式架构实战 ","date":"2020-01-01","objectID":"/javaoutline/:5:0","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"四大理论 拜占庭将军问题 CAP 理论 ACID 理论 BASE 理论 ","date":"2020-01-01","objectID":"/javaoutline/:5:1","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"八大协议/算法 Paxos 算法 Raft 算法 一致性 Hash 算法 Gossip 协议算法 Quorum NWR 算法 FBFT 算法 POW 算法 ZAB 协议 ","date":"2020-01-01","objectID":"/javaoutline/:5:2","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"微服务 ","date":"2020-01-01","objectID":"/javaoutline/:6:0","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"工具 版本管理 Git 项目管理 Maven/Gradle 代码质量管理 Sonar 持续集成部署 Jenkins\u0026GitLab CI/CD 监控系统 测试 Postman Jmeter VisualVM ","date":"2020-01-01","objectID":"/javaoutline/:7:0","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["Java基础"],"content":"ConcurrentHashMap详解","date":"2018-04-10","objectID":"/concurrenthashmap/","tags":["数据结构"],"title":"ConcurrentHashMap详解","uri":"/concurrenthashmap/"},{"categories":["Java基础"],"content":"AbstractQueuedSynchronizer详解","date":"2018-04-05","objectID":"/abstractqueuedsynchronizer/","tags":["并发编程"],"title":"AbstractQueuedSynchronizer详解","uri":"/abstractqueuedsynchronizer/"},{"categories":["Java基础"],"content":"AQS\" AQS 上图中有颜色的为Method，无颜色的为Attribution。 总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。 当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。 ","date":"2018-04-05","objectID":"/abstractqueuedsynchronizer/:0:0","tags":["并发编程"],"title":"AbstractQueuedSynchronizer详解","uri":"/abstractqueuedsynchronizer/"},{"categories":["Java基础"],"content":"原理概览 AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。 CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点(Node)来实现锁的分配。 AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。 private volatile int state;//共享变量，使用volatile修饰保证线程可见性 ","date":"2018-04-05","objectID":"/abstractqueuedsynchronizer/:1:0","tags":["并发编程"],"title":"AbstractQueuedSynchronizer详解","uri":"/abstractqueuedsynchronizer/"},{"categories":["Java基础"],"content":"AQS数据结构 AQS数据结构\" AQS数据结构 先来看下AQS中最基本的数据结构——Node，Node即为上面CLH变体队列中的节点。 ","date":"2018-04-05","objectID":"/abstractqueuedsynchronizer/:2:0","tags":["并发编程"],"title":"AbstractQueuedSynchronizer详解","uri":"/abstractqueuedsynchronizer/"},{"categories":["Java基础"],"content":"线程两种资源共享方式 Share(共享)：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock。 Exclusive(独占)：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁： 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的 ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。 不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护(如获取资源失败入队/唤醒出队等)，AQS已经在上层已经帮我们实现好了。 ","date":"2018-04-05","objectID":"/abstractqueuedsynchronizer/:2:1","tags":["并发编程"],"title":"AbstractQueuedSynchronizer详解","uri":"/abstractqueuedsynchronizer/"},{"categories":["Java基础"],"content":"属性值的含义 waitStatus 当前节点在队列中的状态 thread 表示处于该节点的线程 prev 前驱指针 predecessor 返回前驱节点，没有的话抛出npe nextWaiter 指向下一个处于CONDITION状态的节点（由于本篇文章不讲述Condition Queue队列，这个指针不多介绍） next 后继指针 ","date":"2018-04-05","objectID":"/abstractqueuedsynchronizer/:2:2","tags":["并发编程"],"title":"AbstractQueuedSynchronizer详解","uri":"/abstractqueuedsynchronizer/"},{"categories":["Java基础"],"content":"waitStatus有下面几个枚举值 0，表示当前节点在sync queue中，等待着获取锁。 SIGNAL 为-1，表示线程已经准备好了，就等资源释放了,表示当前节点的后继节点包含的线程需要运行，需要进行unpark操作。 CANCELLED 为1，表示线程获取锁的请求已经取消了 CONDITION 为-2，表示当前节点在等待condition，也就是在condition queue中，节点线程等待唤醒 PROPAGATE 为-3，表示当前场景下后续的acquireShared能够得以执行。 AQS独占模式加锁\" AQS独占模式加锁 AQS共享模式加锁\" AQS共享模式加锁 ","date":"2018-04-05","objectID":"/abstractqueuedsynchronizer/:2:3","tags":["并发编程"],"title":"AbstractQueuedSynchronizer详解","uri":"/abstractqueuedsynchronizer/"},{"categories":["Java基础"],"content":"AQS重要方法与ReentrantLock的关联 ","date":"2018-04-05","objectID":"/abstractqueuedsynchronizer/:3:0","tags":["并发编程"],"title":"AbstractQueuedSynchronizer详解","uri":"/abstractqueuedsynchronizer/"},{"categories":["Java基础"],"content":"方法 AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法 protected boolean isHeldExclusively() 该线程是否正在独占资源。只有用到Condition才需要去实现它。 protected boolean tryAcquire(int arg) 独占方式。arg为获取锁的次数，尝试获取资源，成功则返回True，失败则返回False。 protected boolean tryRelease(int arg) 独占方式。arg为释放锁的次数，尝试释放资源，成功则返回True，失败则返回False。 protected int tryAcquireShared(int arg) 共享方式。arg为获取锁的次数，尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 protected boolean tryReleaseShared(int arg) 共享方式。arg为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回True，否则返回False。 默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。 以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0(即释放锁)为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的(state会累加)，这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。 一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。ReentrantLock是独占锁，所以实现了tryAcquire-tryRelease。 以非公平锁为例，这里主要阐述一下非公平锁与AQS之间方法的关联之处，具体每一处核心方法的作用会在文章后面详细进行阐述。 ReentrantLock加锁流程\" ReentrantLock加锁流程 为了帮助大家理解ReentrantLock和AQS之间方法的交互过程，以非公平锁为例，我们将加锁和解锁的交互流程单独拎出来强调一下，以便于对后续内容的理解。 ReentrantLock流程梳理\" ReentrantLock流程梳理 ","date":"2018-04-05","objectID":"/abstractqueuedsynchronizer/:3:1","tags":["并发编程"],"title":"AbstractQueuedSynchronizer详解","uri":"/abstractqueuedsynchronizer/"},{"categories":["Java基础"],"content":"加锁： 通过ReentrantLock的加锁方法Lock进行加锁操作。 会调用到内部类Sync的Lock方法，由于Sync#lock是抽象方法，根据ReentrantLock初始化选择的公平锁和非公平锁，执行相关内部类的Lock方法，本质上都会执行AQS的Acquire方法。 AQS的Acquire方法会执行tryAcquire方法，但是由于tryAcquire需要自定义同步器实现，因此执行了ReentrantLock中的tryAcquire方法，由于ReentrantLock是通过公平锁和非公平锁内部类实现的tryAcquire方法，因此会根据锁类型不同，执行不同的tryAcquire。 tryAcquire是获取锁逻辑，获取失败后，会执行框架AQS的后续逻辑，跟ReentrantLock自定义同步器无关。 ","date":"2018-04-05","objectID":"/abstractqueuedsynchronizer/:3:2","tags":["并发编程"],"title":"AbstractQueuedSynchronizer详解","uri":"/abstractqueuedsynchronizer/"},{"categories":["Java基础"],"content":"解锁： 通过ReentrantLock的解锁方法Unlock进行解锁。 Unlock会调用内部类Sync的Release方法，该方法继承于AQS。 Release中会调用tryRelease方法，tryRelease需要自定义同步器实现，tryRelease只在ReentrantLock中的Sync实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。 释放成功后，所有处理由AQS框架完成，与自定义同步器无关。 通过上面的描述，大概可以总结出ReentrantLock加锁解锁时API层核心方法的映射关系。 ReentrantLock映射关系\" ReentrantLock映射关系 ","date":"2018-04-05","objectID":"/abstractqueuedsynchronizer/:3:3","tags":["并发编程"],"title":"AbstractQueuedSynchronizer详解","uri":"/abstractqueuedsynchronizer/"},{"categories":["Java基础"],"content":"通过ReentrantLock理解AQS ReentrantLock中公平锁和非公平锁在底层是相同的，这里以非公平锁为例进行分析。 // java.util.concurrent.locks.ReentrantLock static final class NonfairSync extends Sync { ... final void lock() { if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); } ... } // java.util.concurrent.locks.AbstractQueuedSynchronizer public final void acquire(int arg) { if (!tryAcquire(arg) \u0026\u0026 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } // java.util.concurrent.locks.AbstractQueuedSynchronizer protected boolean tryAcquire(int arg) { throw new UnsupportedOperationException(); } 可以看出，这里只是AQS的简单实现，具体获取锁的实现方法是由各自的公平锁和非公平锁单独实现的（以ReentrantLock为例）。如果该方法返回了True，则说明当前线程获取锁成功，就不用往后执行了；如果获取失败，就需要加入到等待队列中。下面会详细解释线程是何时以及怎样被加入进等待队列中的。 ","date":"2018-04-05","objectID":"/abstractqueuedsynchronizer/:4:0","tags":["并发编程"],"title":"AbstractQueuedSynchronizer详解","uri":"/abstractqueuedsynchronizer/"},{"categories":["Java基础"],"content":"线程加入等待队列 加入队列的时机 当执行Acquire(1)时，会通过tryAcquire获取锁。在这种情况下，如果获取锁失败，就会调用addWaiter加入到等待队列中去。 如何加入队列 获取锁失败后，会执行addWaiter(Node.EXCLUSIVE)加入等待队列，具体实现方法如下： // java.util.concurrent.locks.AbstractQueuedSynchronizer private Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node; } private final boolean compareAndSetTail(Node expect, Node update) { return unsafe.compareAndSwapObject(this, tailOffset, expect, update); } 主要的流程如下： 通过当前的线程和锁模式新建一个节点。 Pred指针指向尾节点Tail。 将New中Node的Prev指针指向Pred。 通过compareAndSetTail方法，完成尾节点的设置。这个方法主要是对tailOffset和Expect进行比较，如果tailOffset的Node和Expect的Node地址是相同的，那么设置Tail的值为Update的值。 // java.util.concurrent.locks.AbstractQueuedSynchronizer static { try { stateOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(\"state\")); headOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(\"head\")); tailOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(\"tail\")); waitStatusOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(\"waitStatus\")); nextOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(\"next\")); } catch (Exception ex) { throw new Error(ex); } 从AQS的静态代码块可以看出，都是获取一个对象的属性相对于该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。tailOffset指的是tail对应的偏移量，所以这个时候会将new出来的Node置为当前队列的尾节点。同时，由于是双向链表，也需要将前一个节点指向尾节点。 如果Pred指针是Null（说明等待队列中没有元素），或者当前Pred指针和Tail指向的位置不同（说明被别的线程已经修改），就需要看一下Enq的方法。 // java.util.concurrent.locks.AbstractQueuedSynchronizer private Node enq(final Node node) { for (;;) { Node t = tail; if (t == null) { // Must initialize if (compareAndSetHead(new Node())) tail = head; } else { node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } } } 如果没有被初始化，需要进行初始化一个头结点出来。但请注意，初始化的头结点并不是当前线程节点，而是调用了无参构造函数的节点。如果经历了初始化或者并发导致队列中有元素，则与之前的方法相同。其实，addWaiter就是一个在双端链表添加尾节点的操作，需要注意的是，双端链表的头结点是一个无参构造函数的头结点。 总结一下，线程获取锁的时候，过程大体如下： 当没有线程获取到锁时，线程1获取锁成功。 线程2申请锁，但是锁被线程1占有。 如果再有线程要获取锁，依次在队列中往后排队即可。 等待队列中线程出队列时机 回到最初的源码： // java.util.concurrent.locks.AbstractQueuedSynchronizer public final void acquire(int arg) { if (!tryAcquire(arg) \u0026\u0026 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } 上文解释了addWaiter方法，这个方法其实就是把对应的线程以Node的数据结构形式加入到双端队列里，返回的是一个包含该线程的Node。而这个Node会作为参数，进入到acquireQueued方法中。acquireQueued方法可以对排队中的线程进行“获锁”操作。 总的来说，一个线程获取锁失败了，被放入等待队列，acquireQueued会把放入队列中的线程不断去获取锁，直到获取成功或者不再需要获取（中断）。 下面我们从“何时出队列？”和“如何出队列？”两个方向来分析一下acquireQueued源码： // java.util.concurrent.locks.AbstractQueuedSynchronizer final boolean acquireQueued(final Node node, int arg) { // 标记是否成功拿到资源 boolean failed = true; try { // 标记等待过程中是否中断过 boolean interrupted = false; // 开始自旋，要么获取锁，要么中断 for (;;) { // 获取当前节点的前驱节点 final Node p = node.predecessor(); // 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点） if (p == head \u0026\u0026 tryAcquire(arg)) { // 获取锁成功，头指针移动到当前node setHead(node); p.next = null; // help GC failed = false; return interrupted; } // 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者是p不为头结点，这个时候就要判断当前node是否要被阻塞（被阻塞条件：前驱节点的waitStatus为-1），防止无限循环浪费资源。具体两个方法下面细细分析 if (shouldParkAfterFailedAcquire(p, node) \u0026\u0026 parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } } 注：setHead方法是把当前节点置为虚节点，但并没有修改waitStatus，因为它是一直需要用的数据。 // java.util.concurrent.locks.AbstractQueuedSynchronizer private void setHead(Node node) { head = node; node.thread = null; node.prev = null; } // java.util.concurrent.locks.AbstractQueuedSynchronizer // 靠前驱节点判断当前线程是否应该被阻塞 private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) { // 获取头结点的节点状态 int ws = pred.waitStatus; // 说明头结点处于唤醒状态 if (ws == Node.SIGNAL) return true; // 通过枚举值我们知道waitStatus\u003e0是取消状态 if (ws \u003e 0) { do { // 循环向前查找取消节点，把取消节点从队列中剔除 node.prev = pred = pred.prev; } while (pred.waitStatus \u003e 0); pred.next = node; } else { // 设置前任节点等待状态为SIGNAL compareAndSetWaitS","date":"2018-04-05","objectID":"/abstractqueuedsynchronizer/:4:1","tags":["并发编程"],"title":"AbstractQueuedSynchronizer详解","uri":"/abstractqueuedsynchronizer/"},{"categories":["Java基础"],"content":"如何解锁 我们已经剖析了加锁过程中的基本流程，接下来再对解锁的基本流程进行分析。由于ReentrantLock在解锁的时候，并不区分公平锁和非公平锁，所以我们直接看解锁的源码： // java.util.concurrent.locks.ReentrantLock public void unlock() { sync.release(1); } // java.util.concurrent.locks.AbstractQueuedSynchronizer // 可以看到，本质释放锁的地方，是通过框架来完成的。 public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null \u0026\u0026 h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } //在ReentrantLock里面的公平锁和非公平锁的父类Sync定义了可重入锁的释放锁机制。 // java.util.concurrent.locks.ReentrantLock.Sync // 方法返回当前锁是不是没有被线程持有 protected final boolean tryRelease(int releases) { // 减少可重入次数 int c = getState() - releases; // 当前线程不是持有锁的线程，抛出异常 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; // 如果持有线程全部释放，将当前独占锁所有线程设置为null，并更新state if (c == 0) { free = true; setExclusiveOwnerThread(null); } setState(c); return free; } // java.util.concurrent.locks.AbstractQueuedSynchronizer public final boolean release(int arg) { // 上边自定义的tryRelease如果返回true，说明该锁没有被任何线程持有 if (tryRelease(arg)) { // 获取头结点 Node h = head; // 头结点不为空并且头结点的waitStatus不是初始化节点情况，解除线程挂起状态 if (h != null \u0026\u0026 h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } //再看一下unparkSuccessor方法 // java.util.concurrent.locks.AbstractQueuedSynchronizer private void unparkSuccessor(Node node) { // 获取头结点waitStatus int ws = node.waitStatus; if (ws \u003c 0) compareAndSetWaitStatus(node, ws, 0); // 获取当前节点的下一个节点 Node s = node.next; // 如果下个节点是null或者下个节点被cancelled，就找到队列最开始的非cancelled的节点 if (s == null || s.waitStatus \u003e 0) { s = null; // 就从尾部节点开始找，到队首，找到队列第一个waitStatus\u003c0的节点。 for (Node t = tail; t != null \u0026\u0026 t != node; t = t.prev) if (t.waitStatus \u003c= 0) s = t; } // 如果当前节点的下个节点不为空，而且状态\u003c=0，就把当前节点unpark if (s != null) LockSupport.unpark(s.thread); } // 为什么要从后往前找第一个非Cancelled的节点呢？原因如下。 // 之前的addWaiter方法： // java.util.concurrent.locks.AbstractQueuedSynchronizer private Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node; } 我们从这里可以看到，节点入队并不是原子操作，也就是说，node.prev = pred; compareAndSetTail(pred, node) 这两个地方可以看作Tail入队的原子操作，但是此时pred.next = node;还没执行，如果这个时候执行了unparkSuccessor方法，就没办法从前往后找了，所以需要从后往前找。还有一点原因，在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的Node。 综上所述，如果是从前往后找，由于极端情况下入队的非原子操作和CANCELLED节点产生过程中断开Next指针的操作，可能会导致无法遍历所有的节点。所以，唤醒对应的线程后，对应的线程就会继续往下执行。继续执行acquireQueued方法以后，中断如何处理？ ","date":"2018-04-05","objectID":"/abstractqueuedsynchronizer/:4:2","tags":["并发编程"],"title":"AbstractQueuedSynchronizer详解","uri":"/abstractqueuedsynchronizer/"},{"categories":["Java基础"],"content":"中断恢复后的执行流程 唤醒后，会执行return Thread.interrupted();，这个函数返回的是当前执行线程的中断状态，并清除。 // java.util.concurrent.locks.AbstractQueuedSynchronizer private final boolean parkAndCheckInterrupt() { LockSupport.park(this); return Thread.interrupted(); } 再回到acquireQueued代码，当parkAndCheckInterrupt返回True或者False的时候，interrupted的值不同，但都会执行下次循环。如果这个时候获取锁成功，就会把当前interrupted返回。 // java.util.concurrent.locks.AbstractQueuedSynchronizer final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); if (p == head \u0026\u0026 tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return interrupted; } if (shouldParkAfterFailedAcquire(p, node) \u0026\u0026 parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } } 如果acquireQueued为True，就会执行selfInterrupt方法。 // java.util.concurrent.locks.AbstractQueuedSynchronizer static void selfInterrupt() { Thread.currentThread().interrupt(); } 该方法其实是为了中断线程。但为什么获取了锁以后还要中断线程呢？这部分属于Java提供的协作式中断知识内容，感兴趣同学可以查阅一下。这里简单介绍一下： 当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们通过Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为False），并记录下来，如果发现该线程被中断过，就再中断一次。 线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。 ","date":"2018-04-05","objectID":"/abstractqueuedsynchronizer/:4:3","tags":["并发编程"],"title":"AbstractQueuedSynchronizer详解","uri":"/abstractqueuedsynchronizer/"},{"categories":["Java基础"],"content":"AbstractQueuedSynchronizer总结 对于AbstractQueuedSynchronizer的分析，最核心的就是sync queue的分析。 每一个结点都是由前一个结点唤醒 当结点发现前驱结点是head并且尝试获取成功，则会轮到该线程运行。 condition queue中的结点向sync queue中转移是通过条件的signal()操作完成的。 当结点的状态为SIGNAL时，表示后面的结点需要运行。 ","date":"2018-04-05","objectID":"/abstractqueuedsynchronizer/:5:0","tags":["并发编程"],"title":"AbstractQueuedSynchronizer详解","uri":"/abstractqueuedsynchronizer/"},{"categories":["Java基础"],"content":"参考文章 从ReentrantLock的实现看AQS的原理及应用 锁核心类AQS详解 ","date":"2018-04-05","objectID":"/abstractqueuedsynchronizer/:6:0","tags":["并发编程"],"title":"AbstractQueuedSynchronizer详解","uri":"/abstractqueuedsynchronizer/"},{"categories":["Java基础"],"content":"LockSupport详解","date":"2018-04-04","objectID":"/locksupport/","tags":["并发编程"],"title":"LockSupport详解","uri":"/locksupport/"},{"categories":["Java基础"],"content":"LockSupport简介 LockSupport用来创建锁和其他同步类的基本线程阻塞原语。简而言之，当调用LockSupport.park时，表示当前线程将会等待，直至获得许可，当调用LockSupport.unpark时，必须把等待获得许可的线程作为参数进行传递，好让此线程继续运行。 ","date":"2018-04-04","objectID":"/locksupport/:1:0","tags":["并发编程"],"title":"LockSupport详解","uri":"/locksupport/"},{"categories":["Java基础"],"content":"核心函数分析 在分析LockSupport函数之前，先引入sun.misc.Unsafe类中的park和unpark函数，因为LockSupport的核心函数都是基于Unsafe类中定义的park和unpark函数，下面给出两个函数的定义: public native void park(boolean isAbsolute, long time); public native void unpark(Thread thread); 说明: 对两个函数的说明如下: park函数，阻塞线程，并且该线程在下列情况发生之前都会被阻塞: ① 调用unpark函数，释放该线程的许可。② 该线程被中断。③ 设置的时间到了。并且，当time为绝对时间时，isAbsolute为true，否则，isAbsolute为false。当time为0时，表示无限等待，直到unpark发生。 unpark函数，释放线程的许可，即激活调用park后阻塞的线程。这个函数不是安全的，调用这个函数时要确保线程依旧存活。 ","date":"2018-04-04","objectID":"/locksupport/:2:0","tags":["并发编程"],"title":"LockSupport详解","uri":"/locksupport/"},{"categories":["Java基础"],"content":"park函数 park函数有两个重载版本，方法摘要如下 public static void park()； public static void park(Object blocker)； 说明: 两个函数的区别在于park()函数没有没有blocker，即没有设置线程的parkBlocker字段。park(Object)型函数如下。 public static void park(Object blocker) { // 获取当前线程 Thread t = Thread.currentThread(); // 设置Blocker setBlocker(t, blocker); // 获取许可 UNSAFE.park(false, 0L); // 重点方法：重新可运行后再此设置Blocker，其他线程执行unpark()后继续 setBlocker(t, null); } 说明: 调用park函数时，首先获取当前线程，然后设置当前线程的parkBlocker字段，即调用setBlocker函数，之后调用Unsafe类的park函数，之后再调用setBlocker函数。 那么问题来了，为什么要在此park函数中要调用两次setBlocker函数呢? 原因其实很简单，调用park函数时，当前线程首先设置好parkBlocker字段，然后再调用Unsafe的park函数，此后，当前线程就已经阻塞了，等待该线程的unpark函数被调用，所以后面的一个setBlocker函数无法运行，unpark函数被调用，该线程获得许可后，就可以继续运行了，也就运行第二个setBlocker，把该线程的parkBlocker字段设置为null，这样就完成了整个park函数的逻辑。如果没有第二个setBlocker，那么之后没有调用park(Object blocker)，而直接调用getBlocker函数，得到的还是前一个park(Object blocker)设置的blocker，显然是不符合逻辑的。 总之，必须要保证在park(Object blocker)整个函数执行完后，该线程的parkBlocker字段又恢复为null。所以，park(Object)型函数里必须要调用setBlocker函数两次。 setBlocker方法如下: private static void setBlocker(Thread t, Object arg) { // 设置线程t的parkBlocker字段的值为arg UNSAFE.putObject(t, parkBlockerOffset, arg); } ","date":"2018-04-04","objectID":"/locksupport/:2:1","tags":["并发编程"],"title":"LockSupport详解","uri":"/locksupport/"},{"categories":["Java基础"],"content":"unpark函数 此函数表示如果给定线程的许可尚不可用，则使其可用。如果线程在 park 上受阻塞，则它将解除其阻塞状态。否则，保证下一次调用 park 不会受阻塞。如果给定线程尚未启动，则无法保证此操作有任何效果。具体函数如下: public static void unpark(Thread thread) { if (thread != null) // 线程为不空 UNSAFE.unpark(thread); // 释放该线程许可 } ","date":"2018-04-04","objectID":"/locksupport/:2:2","tags":["并发编程"],"title":"LockSupport详解","uri":"/locksupport/"},{"categories":["Java基础"],"content":"更深入的理解 ","date":"2018-04-04","objectID":"/locksupport/:3:0","tags":["并发编程"],"title":"LockSupport详解","uri":"/locksupport/"},{"categories":["Java基础"],"content":"Thread.sleep()和Object.wait()的区别 Thread.sleep()不会释放占有的锁，Object.wait()会释放占有的锁； Thread.sleep()必须传入时间，Object.wait()可传可不传，不传表示一直阻塞下去； Thread.sleep()到时间了会自动唤醒，然后继续执行； Object.wait()不带时间的，需要另一个线程使用Object.notify()唤醒； Object.wait()带时间的，假如没有被notify，到时间了会自动唤醒，这时又分好两种情况，一是立即获取到了锁，线程自然会继续执行；二是没有立即获取锁，线程进入同步队列等待获取锁； 其实，他们俩最大的区别就是Thread.sleep()不会释放锁资源，Object.wait()会释放锁资源。 ","date":"2018-04-04","objectID":"/locksupport/:3:1","tags":["并发编程"],"title":"LockSupport详解","uri":"/locksupport/"},{"categories":["Java基础"],"content":"Thread.sleep()和Condition.await()的区别 Condition.await()和Object.wait()的原理是基本一致的，不同的是Condition.await()底层是调用LockSupport.park()来实现阻塞当前线程的。 实际上，它在阻塞当前线程之前还干了两件事，一是把当前线程添加到条件队列中，二是“完全”释放锁，也就是让state状态变量变为0，然后才是调用LockSupport.park()阻塞当前线程。 ","date":"2018-04-04","objectID":"/locksupport/:3:2","tags":["并发编程"],"title":"LockSupport详解","uri":"/locksupport/"},{"categories":["Java基础"],"content":"Thread.sleep()和LockSupport.park()的区别 LockSupport.park()还有几个兄弟方法——parkNanos()、parkUtil()等，我们这里说的park()方法统称这一类方法。 从功能上来说，Thread.sleep()和LockSupport.park()方法类似，都是阻塞当前线程的执行，且都不会释放当前线程占有的锁资源。 Thread.sleep()没法从外部唤醒，只能自己醒过来； LockSupport.park()方法可以被另一个线程调用LockSupport.unpark()方法唤醒； Thread.sleep()方法声明上抛出了InterruptedException中断异常，所以调用者需要捕获这个异常或者再抛出； LockSupport.park()方法不需要捕获中断异常； Thread.sleep()本身就是一个native方法； LockSupport.park()底层是调用的Unsafe的native方法 ","date":"2018-04-04","objectID":"/locksupport/:3:3","tags":["并发编程"],"title":"LockSupport详解","uri":"/locksupport/"},{"categories":["Java基础"],"content":"Object.wait()和LockSupport.park()的区别 二者都会阻塞当前线程的运行，他们有什么区别呢? 经过上面的分析相信你一定很清楚了，真的吗? 往下看！ Object.wait()方法需要在synchronized块中执行； LockSupport.park()可以在任意地方执行； Object.wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出； LockSupport.park()不需要捕获中断异常； Object.wait()不带超时的，需要另一个线程执行notify()来唤醒，但不一定继续执行后续内容； LockSupport.park()不带超时的，需要另一个线程执行unpark()来唤醒，一定会继续执行后续内容； 如果在wait()之前执行了notify()会怎样? 抛出IllegalMonitorStateException异常； 如果在park()之前执行了unpark()会怎样? 线程不会被阻塞，直接跳过park()，继续执行后续内容； park()/unpark()底层的原理是“二元信号量”，你可以把它相像成只有一个许可证的Semaphore，只不过这个信号量在重复执行unpark()的时候也不会再增加许可证，最多只有一个许可证。 ","date":"2018-04-04","objectID":"/locksupport/:3:4","tags":["并发编程"],"title":"LockSupport详解","uri":"/locksupport/"},{"categories":["Java基础"],"content":"LockSupport.park()不会释放锁资源 LockSupport.park()不会释放锁资源，它只负责阻塞当前线程，释放锁资源实际上是在Condition的await()方法中实现的。 ","date":"2018-04-04","objectID":"/locksupport/:3:5","tags":["并发编程"],"title":"LockSupport详解","uri":"/locksupport/"},{"categories":["Java基础"],"content":"synchronized详解","date":"2018-04-03","objectID":"/synchronized/","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"synchronized的使用 ","date":"2018-04-03","objectID":"/synchronized/:1:0","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"对象锁 包括方法锁(默认锁对象为this,当前实例对象)和同步代码块锁(自己指定锁对象) ","date":"2018-04-03","objectID":"/synchronized/:1:1","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"类锁 指synchronize修饰静态的方法或指定锁对象为Class对象 ","date":"2018-04-03","objectID":"/synchronized/:1:2","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"注意点 一把锁只能同时被一个线程获取，没有获得锁的线程只能等待。 每个实例都对应有自己的一把锁(this),不同实例之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象共用同一把锁 。 synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁。 ","date":"2018-04-03","objectID":"/synchronized/:1:3","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"synchronized原理分析 ","date":"2018-04-03","objectID":"/synchronized/:2:0","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"加锁和释放锁的原理 Monitorenter和Monitorexit指令，会让对象在执行，使其锁计数器加1或者减1。每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的Monitor锁的所有权的时候，monitorenter指令会发生如下3中情况之一： monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待 如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加 这把锁已经被别的线程获取了，等待锁释放 monitorexit指令：释放对于monitor的所有权，释放过程很简单，就是讲monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁。 schronized-moniter\" schronized-moniter 该图可以看出，任意线程对Object的访问，首先要获得Object的监视器，如果获取失败，该线程就进入同步状态，线程状态变为BLOCKED，当Object的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。 ","date":"2018-04-03","objectID":"/synchronized/:2:1","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"可重入原理：加锁次数计数器 上面的demo中在执行完同步代码块之后紧接着再会去执行一个静态同步方法，而这个方法锁的对象依然就这个类对象，那么这个正在执行的线程还需要获取该锁吗? 答案是不必的，从上图中就可以看出来，执行静态同步方法的时候就只有一条monitorexit指令，并没有monitorenter获取锁的指令。这就是锁的重入性，即在同一锁程中，线程不需要再次获取同一把锁。 synchronized先天具有重入性。每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一。 ","date":"2018-04-03","objectID":"/synchronized/:2:2","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"保证可见性的原理：内存模型和happens-before规则 Synchronized的happens-before规则，即监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁。继续来看代码： public class MonitorDemo { private int a = 0; public synchronized void writer() { // 1 a++; // 2 } // 3 public synchronized void reader() { // 4 int i = a; // 5 } // 6 } 该代码的happens-before关系如图所示： happens-before\" happens-before 在图中每一个箭头连接的两个节点就代表之间的happens-before关系，黑色的是通过程序顺序规则推导出来，红色的为监视器锁规则推导而出：线程A释放锁happens-before线程B加锁，蓝色的则是通过程序顺序规则和监视器锁规则推测出来happens-befor关系，通过传递性规则进一步推导的happens-before关系。现在我们来重点关注2 happens-before 5，通过这个关系我们可以得出什么? 根据happens-before的定义中的一条:如果A happens-before B，则A的执行结果对B可见，并且A的执行顺序先于B。线程A先对共享变量A进行加一，由2 happens-before 5关系可知线程A的执行结果对线程B可见即线程B所读取到的a的值为1。 ","date":"2018-04-03","objectID":"/synchronized/:2:3","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"JVM中锁的优化 简单来说在JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的。 但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的；然而在现实中的大部分情况下，同步方法是运行在单线程环境(无锁竞争环境)如果每次都调用Mutex Lock那么将严重的影响程序的性能。 不过在jdk1.6中对锁的实现引入了大量的优化，如锁粗化(Lock Coarsening)、锁消除(Lock Elimination)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销。 ","date":"2018-04-03","objectID":"/synchronized/:3:0","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"锁优化 锁粗化(Lock Coarsening)：也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。 锁消除(Lock Elimination)：通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本地Stack上进行对象空间的分配(同时还可以减少Heap上的垃圾收集开销)。 偏向锁(Biased Locking)：是为了在无锁竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟。 轻量级锁(Lightweight Locking)：这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态(即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒(具体处理步骤下面详细讨论)。 自适应自旋锁(Adaptive Spinning)：当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁(mutex semaphore)前会进入忙等待(Spinning)然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该monitor关联的semaphore(即互斥锁)进入到阻塞状态。 ","date":"2018-04-03","objectID":"/synchronized/:3:1","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"锁的类型 在Java SE 1.6里Synchronied同步锁，一共有四种状态：无锁、偏向锁、轻量级所、重量级锁，它会随着竞争情况逐渐升级。 锁可以升级但是不可以降级，目的是为了提供获取锁和释放锁的效率。 锁膨胀方向(不可逆)： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 流程：偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。 下面是各个过程的详细介绍： ","date":"2018-04-03","objectID":"/synchronized/:3:2","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"自旋锁与自适应自旋锁 自旋锁对比非自旋锁\" 自旋锁对比非自旋锁 自旋锁 引入背景：大家都知道，在没有加入锁优化时，Synchronized是一个非常“胖大”的家伙。在多线程竞争锁时，当一个线程获取锁时，它会阻塞所有正在竞争的线程，这样对性能带来了极大的影响。在挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作对系统的并发性能带来了很大的压力。同时HotSpot团队注意到在很多情况下，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和回复阻塞线程并不值得。在如今多处理器环境下，完全可以让另一个没有获取到锁的线程在门外等待一会(自旋)，但不放弃CPU的执行时间。等待持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需要让线程执行一个忙循环(自旋)，这便是自旋锁由来的原因。 自旋锁早在JDK1.4 中就引入了，只是当时默认时关闭的。在JDK 1.6后默认为开启状态。 自旋锁本质上与阻塞并不相同，先不考虑其对多处理器的要求，如果锁占用的时间非常的短，那么自旋锁的性能会非常的好，相反，其会带来更多的性能开销(因为在线程自旋时，始终会占用CPU的时间片，如果锁占用的时间太长，那么自旋的线程会白白消耗掉CPU资源)。 因此自旋等待的时间必须要有一定的限度，如果自选超过了限定的次数仍然没有成功获取到锁，就应该使用传统的方式去挂起线程了，在JDK定义中，自旋锁默认的自旋次数为10次，用户可以使用参数-XX:PreBlockSpin来更改。 可是现在又出现了一个问题：如果线程锁在线程自旋刚结束就释放掉了锁，那么是不是有点得不偿失。所以这时候我们需要更加聪明的锁来实现更加灵活的自旋。来提高并发的性能。(这里则需要自适应自旋锁) 自适应自旋锁 在JDK 1.6中引入了自适应自旋锁。这就意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。 如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。 比如增加到100此循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。 有了自适应自旋，JVM对程序的锁的状态预测会越来越准备，JVM也会越来越聪明。 ","date":"2018-04-03","objectID":"/synchronized/:3:3","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"锁消除 锁消除时指虚拟机即时编译器再运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。 锁消除的主要判定依据来源于逃逸分析的数据支持。意思就是：JVM会判断再一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那JVM就把它们当作栈上数据对待，认为这些数据时线程独有的，不需要加同步。此时就会进行锁消除。 ​ 当然在实际开发中，我们很清楚的知道那些地方时线程独有的，不需要加同步锁，但是在Java API中有很多方法都是加了同步的，那么此时JVM会判断这段代码是否需要加锁。如果数据并不会逃逸，则会进行锁消除。比如如下操作：在操作String类型数据时，由于String是一个不可变类，对字符串的连接操作总是通过生成的新的String对象来进行的。因此Javac编译器会对String连接做自动优化。在JDK 1.5之前会使用StringBuffer对象的连续append()操作，在JDK 1.5及以后的版本中，会转化为StringBuidler对象的连续append()操作。 public static String test03(String s1, String s2, String s3) { String s = s1 + s2 + s3; return s; } 上述代码使用javap 编译结果 锁消除\" 锁消除 众所周知，StringBuilder不是安全同步的，但是在上述代码中，JVM判断该段代码并不会逃逸，则将该代码带默认为线程独有的资源，并不需要同步，所以执行了锁消除操作。(还有Vector中的各种操作也可实现锁消除。在没有逃逸出数据安全防卫内) ","date":"2018-04-03","objectID":"/synchronized/:3:4","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"锁粗化 ​原则上，我们都知道在加同步锁时，尽可能的将同步块的作用范围限制到尽量小的范围(只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。在存在锁同步竞争中，也可以使得等待锁的线程尽早的拿到锁)。 ​大部分上述情况是完美正确的，但是如果存在连串的一系列操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要地性能操作。 ","date":"2018-04-03","objectID":"/synchronized/:3:5","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"偏向锁 引入背景：在大多实际环境下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，那么在同一个线程反复获取所释放锁中，其中并还没有锁的竞争，那么这样看上去，多次的获取锁和释放锁带来了很多不必要的性能开销和上下文切换。 ​ 为了解决这一问题，HotSpot的作者在Java SE1.6中对Synchronized进行了优化，引入了偏向锁。 当一个线程访问同步快并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁。只需要简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。 偏向锁1\" 偏向锁1 偏向锁的撤销 偏向锁使用了一种等待竞争出现才会释放锁的机制，所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。 但是偏向锁的撤销需要等到全局安全点(就是当前线程没有正在执行的字节码)。 它会首先暂停拥有偏向锁的线程，让你后检查持有偏向锁的线程是否活着。 如果线程不处于活动状态，直接将对象头设置为无锁状态。 如果线程活着，JVM会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。 偏向锁2\" 偏向锁2 ","date":"2018-04-03","objectID":"/synchronized/:3:6","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"轻量级锁 引入背景：这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态(即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒。 ​在JDK 1.6之后引入的轻量级锁，需要注意的是轻量级锁并不是替代重量级锁的，而是对在大多数情况下同步块并不会有竞争出现提出的一种优化。 它可以减少重量级锁对线程的阻塞带来地线程开销，从而提高并发性能。 ​如果要理解轻量级锁，那么必须先要了解HotSpot虚拟机中对象头地内存布局。 在对象头中(Object Header)存在两部分： 第一部分用于存储对象自身的运行时数据，HashCode、GCAge、锁标记位、是否为偏向锁等。一般为32位或者64位(视操作系统位数定)。官方称之为Mark Word，它是实现轻量级锁和偏向锁的关键。 另外一部分存储的是指向方法区对象类型数据的指针(Klass Point)，如果对象是数组的话，还会有一个额外的部分用于存储数据的长度。 轻量级锁加锁 在线程执行同步块之前，JVM会先在当前线程的栈帧中创建一个名为锁记录(Lock Record)的空间，用于存储锁对象目前的Mark Word的拷贝(JVM会将对象头中的Mark Word拷贝到锁记录中，官方称为Displaced Mark Ward)这个时候线程堆栈与对象头的状态如图： 轻量级锁加锁1\" 轻量级锁加锁1 如上图所示：如果当前对象没有被锁定，那么锁标志位位01状态，JVM在执行当前线程时，首先会在当前线程栈帧中创建锁记录Lock Record的空间用于存储锁对象目前的Mark Word的拷贝。 ​ 然后，虚拟机使用CAS操作将标记字段Mark Word拷贝到锁记录中，并且将Mark Word更新为指向Lock Record的指针。如果更新成功了，那么这个线程就有用了该对象的锁，并且对象Mark Word的锁标志位更新为(Mark Word中最后的2bit)00，即表示此对象处于轻量级锁定状态，如图： 轻量级锁加锁2\" 轻量级锁加锁2 如果这个更新操作失败，JVM会检查当前的Mark Word中是否存在指向当前线程的栈帧的指针，如果有，说明该锁已经被获取，可以直接调用。如果没有，则说明该锁被其他线程抢占了，如果**有两条以上的线程竞争同一个锁，那轻量级锁就不再有效，直接膨胀位重量级锁，没有获得锁的线程会被阻塞。**此时，锁的标志位为10，Mark Word中存储的时指向重量级锁的指针。 ​ 轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头中，如果成功，则表示没有发生竞争关系。如果失败，表示当前锁存在竞争关系。锁就会膨胀成重量级锁。两个线程同时争夺锁，导致锁膨胀的流程图如下： 轻量级锁加锁3\" 轻量级锁加锁3 ","date":"2018-04-03","objectID":"/synchronized/:3:7","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"锁的优缺点对比 锁 优点 缺点 使用场景 偏向锁 加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 适用于只有一个线程访问同步快的场景 轻量级锁 竞争的线程不会阻塞，提高了响应速度 如线程成始终得不到锁竞争的线程，使用自旋会消耗CPU性能 追求响应时间，同步快执行速度非常快 重量级锁 线程竞争不适用自旋，不会消耗CPU 线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗 追求吞吐量，同步快执行速度较长 锁对比\" 锁对比 ","date":"2018-04-03","objectID":"/synchronized/:3:8","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"synchronized与Lock ","date":"2018-04-03","objectID":"/synchronized/:4:0","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"synchronized的缺陷 效率低：锁的释放情况少，只有代码执行完毕或者异常结束才会释放锁；试图获取锁的时候不能设定超时，不能中断一个正在使用锁的线程，相对而言，Lock可以中断和设置超时 不够灵活：加锁和释放的时机单一，每个锁仅有一个单一的条件(某个对象)，相对而言，读写锁更加灵活 无法知道是否成功获得锁，相对而言，Lock可以拿到状态。 ","date":"2018-04-03","objectID":"/synchronized/:4:1","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"Lock解决相应问题 Lock类这里不做过多解释，主要看里面的4个方法: lock(): 加锁 unlock(): 解锁 tryLock(): 尝试获取锁，返回一个boolean值 tryLock(long,TimeUtil): 尝试获取锁，可以设置超时 Synchronized只有锁只与一个条件(是否获取锁)相关联，不灵活，后来Condition与Lock的结合解决了这个问题。 多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断。高并发的情况下会导致性能下降。ReentrantLock的lockInterruptibly()方法可以优先考虑响应中断。 一个线程等待时间过长，它可以中断自己，然后ReentrantLock响应这个中断，不再让这个线程继续等待。有了这个机制，使用ReentrantLock时就不会像synchronized那样产生死锁了。 ","date":"2018-04-03","objectID":"/synchronized/:4:2","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"再深入理解 synchronized是通过软件(JVM)实现的，简单易用，即使在JDK5之后有了Lock，仍然被广泛地使用。 ","date":"2018-04-03","objectID":"/synchronized/:5:0","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"使用synchronized注意点 避免死锁 锁对象不能为空，因为锁的信息都保存在对象头里 作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错 在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错 ","date":"2018-04-03","objectID":"/synchronized/:5:1","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"synchronized是公平锁吗？ synchronized实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待，不过这种抢占的方式可以预防饥饿。 ","date":"2018-04-03","objectID":"/synchronized/:5:2","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"参考文章 synchronized详解 不可不说的Java“锁”事 ","date":"2018-04-03","objectID":"/synchronized/:6:0","tags":["并发编程"],"title":"synchronized(无锁→偏向锁→轻量级锁→重量级锁)","uri":"/synchronized/"},{"categories":["Java基础"],"content":"JUC并发编程利器","date":"2018-04-02","objectID":"/juc/","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"JUC概览\" JUC概览 ","date":"2018-04-02","objectID":"/juc/:0:0","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"Lock框架和Tools类 Lock框架和Tools类\" Lock框架和Tools类 ","date":"2018-04-02","objectID":"/juc/:1:0","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"接口Condition Condition为接口类型，它将 Object 监视器方法(wait、notify 和 notifyAll)分解成截然不同的对象，以便通过将这些对象与任意Lock实现组合使用，为每个对象提供多个等待set (wait-set)。其中，Lock替代了synchronized方法和语句的使用，Condition替代了Object监视器方法的使用。可以通过await(),signal()来休眠/唤醒线程。 ","date":"2018-04-02","objectID":"/juc/:1:1","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"接口Lock Lock为接口类型，Lock实现提供了比使用synchronized方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的Condition对象。 ","date":"2018-04-02","objectID":"/juc/:1:2","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"接口ReadWriteLock ReadWriteLock为接口类型， 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。 ","date":"2018-04-02","objectID":"/juc/:1:3","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"抽象类AbstractOwnableSynchonizer AbstractOwnableSynchonizer为抽象类，可以由线程以独占方式拥有的同步器。此类为创建锁和相关同步器(伴随着所有权的概念)提供了基础。AbstractOwnableSynchronizer 类本身不管理或使用此信息。但是，子类和工具可以使用适当维护的值帮助控制和监视访问以及提供诊断。 ","date":"2018-04-02","objectID":"/juc/:1:4","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"抽象类AbstractQueuedLongSynchronizer(long) AbstractQueuedLongSynchronizer为抽象类，以 long 形式维护同步状态的一个 AbstractQueuedSynchronizer 版本。此类具有的结构、属性和方法与 AbstractQueuedSynchronizer 完全相同，但所有与状态相关的参数和结果都定义为 long 而不是 int。当创建需要 64 位状态的多级别锁和屏障等同步器时，此类很有用。 ","date":"2018-04-02","objectID":"/juc/:1:5","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"核心抽象类AbstractQueuedSynchronizer(int) AbstractQueuedSynchronizer为抽象类，其为实现依赖于先进先出 (FIFO) 等待队列的阻塞锁和相关同步器(信号量、事件，等等)提供一个框架。此类的设计目标是成为依靠单个原子int值来表示状态的大多数同步器的一个有用基础。 ","date":"2018-04-02","objectID":"/juc/:1:6","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"锁常用类LockSupport LockSupport为常用类，用来创建锁和其他同步类的基本线程阻塞原语。LockSupport的功能和\"Thread中的 Thread.suspend()和Thread.resume()有点类似”，LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程。但是park()和unpark()不会遇到“Thread.suspend 和 Thread.resume所可能引发的死锁”问题。 ","date":"2018-04-02","objectID":"/juc/:1:7","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"锁常用类ReentrantLock ReentrantLock为常用类，它是一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。 ","date":"2018-04-02","objectID":"/juc/:1:8","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"锁常用类ReentrantReadWriteLock ReentrantReadWriteLock是读写锁接口ReadWriteLock的实现类，它包括Lock子类ReadLock和WriteLock。ReadLock是共享锁，WriteLock是独占锁。 ","date":"2018-04-02","objectID":"/juc/:1:9","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"锁常用类StampedLock 它是java8在java.util.concurrent.locks新增的一个API。StampedLock控制锁有三种模式(写，读，乐观读)，一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。 ","date":"2018-04-02","objectID":"/juc/:1:10","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"工具常用类CountDownLatch CountDownLatch为常用类，它是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。 ","date":"2018-04-02","objectID":"/juc/:1:11","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"工具常用类CyclicBarrier CyclicBarrier为常用类，其是一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。 ","date":"2018-04-02","objectID":"/juc/:1:12","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"工具常用类Phaser Phaser是JDK 7新增的一个同步辅助类，它可以实现CyclicBarrier和CountDownLatch类似的功能，而且它支持对任务的动态调整，并支持分层结构来达到更高的吞吐量。 ","date":"2018-04-02","objectID":"/juc/:1:13","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"工具常用类Semaphore Semaphore为常用类，其是一个计数信号量，从概念上讲，信号量维护了一个许可集。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release() 添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore 只对可用许可的号码进行计数，并采取相应的行动。通常用于限制可以访问某些资源(物理或逻辑的)的线程数目。 ","date":"2018-04-02","objectID":"/juc/:1:14","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"工具常用类Exchanger Exchanger是用于线程协作的工具类, 主要用于两个线程之间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange()方法交换数据，当一个线程先执行exchange()方法后，它会一直等待第二个线程也执行exchange()方法，当这两个线程到达同步点时，这两个线程就可以交换数据了。 ","date":"2018-04-02","objectID":"/juc/:1:15","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"对比 同步工具 同步工具与AQS的关联 ReentrantLock 使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。 Semaphore 使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数。 CountDownLatch 使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。 ReentrantReadWriteLock 使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数。 ThreadPoolExecutor Worker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）。 ","date":"2018-04-02","objectID":"/juc/:1:16","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"Collections: 并发集合 并发集合\" 并发集合 ","date":"2018-04-02","objectID":"/juc/:2:0","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"CAS,Unsafe和原子类 JUC中多数类是通过volatile和CAS来实现的，CAS本质上提供的是一种无锁方案，而Synchronized和Lock是互斥锁方案; Java原子类本质上使用的是CAS，而CAS底层是通过Unsafe类实现的。 ","date":"2018-04-02","objectID":"/juc/:3:0","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"Atomic原子类 其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由JVM从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。实际上是借助硬件的相关指令来实现的，不会阻塞线程(或者说只是在硬件级别上阻塞了)。 ","date":"2018-04-02","objectID":"/juc/:3:1","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"Executors线程池 线程池\" 线程池 ","date":"2018-04-02","objectID":"/juc/:4:0","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"Executor Executor接口提供一种将任务提交与每个任务将如何运行的机制(包括线程使用的细节、调度等)分离开来的方法。通常使用 Executor 而不是显式地创建线程。 ","date":"2018-04-02","objectID":"/juc/:4:1","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"ExecutorService ExecutorService继承自Executor接口，ExecutorService提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。 可以关闭 ExecutorService，这将导致其停止接受新任务。关闭后，执行程序将最后终止，这时没有任务在执行，也没有任务在等待执行，并且无法提交新任务。 ","date":"2018-04-02","objectID":"/juc/:4:2","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"ScheduledExecutorService ScheduledExecutorService继承自ExecutorService接口，可安排在给定的延迟后运行或定期执行的命令。 ","date":"2018-04-02","objectID":"/juc/:4:3","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"AbstractExecutorService AbstractExecutorService继承自ExecutorService接口，其提供 ExecutorService 执行方法的默认实现。此类使用 newTaskFor 返回的 RunnableFuture 实现 submit、invokeAny 和 invokeAll 方法，默认情况下，RunnableFuture 是此包中提供的 FutureTask 类。 ","date":"2018-04-02","objectID":"/juc/:4:4","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"FutureTask FutureTask 为 Future 提供了基础实现，如获取任务执行结果(get)和取消任务(cancel)等。如果任务尚未完成，获取任务执行结果时将会阻塞。一旦执行结束，任务就不能被重启或取消(除非使用runAndReset执行计算)。FutureTask 常用来封装 Callable 和 Runnable，也可以作为一个任务提交到线程池中执行。除了作为一个独立的类之外，此类也提供了一些功能性函数供我们创建自定义 task 类使用。FutureTask 的线程安全由CAS来保证。 ","date":"2018-04-02","objectID":"/juc/:4:5","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"核心: ThreadPoolExecutor ThreadPoolExecutor实现了AbstractExecutorService接口，也是一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。 线程池可以解决两个不同问题: 由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源(包括执行任务集时使用的线程)的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。 ","date":"2018-04-02","objectID":"/juc/:4:6","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"核心: ScheduledThreadExecutor ScheduledThreadPoolExecutor实现ScheduledExecutorService接口，可安排在给定的延迟后运行命令，或者定期执行命令。需要多个辅助线程时，或者要求 ThreadPoolExecutor 具有额外的灵活性或功能时，此类要优于 Timer。 ","date":"2018-04-02","objectID":"/juc/:4:7","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"核心: Fork/Join框架 ForkJoinPool 是JDK 7加入的一个线程池类。Fork/Join 技术是分治算法(Divide-and-Conquer)的并行实现，它是一项可以获得良好的并行性能的简单且高效的设计技术。目的是为了帮助我们更好地利用多处理器带来的好处，使用所有可用的运算能力来提升应用的性能。 ","date":"2018-04-02","objectID":"/juc/:4:8","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"工具类: Executors Executors是一个工具类，用其可以创建ExecutorService、ScheduledExecutorService、ThreadFactory、Callable等对象。它的使用融入到了ThreadPoolExecutor, ScheduledThreadExecutor和ForkJoinPool中。 ","date":"2018-04-02","objectID":"/juc/:4:9","tags":["并发编程","大纲"],"title":"JUC-并发编程利器","uri":"/juc/"},{"categories":["Java基础"],"content":"Java并发编程","date":"2018-04-01","objectID":"/javacurrent/","tags":["并发编程","大纲"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"Java并发编程概览Java并发编程概览 \" Java并发编程概览 ","date":"2018-04-01","objectID":"/javacurrent/:0:0","tags":["并发编程","大纲"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"并发三要素 ","date":"2018-04-01","objectID":"/javacurrent/:1:0","tags":["并发编程","大纲"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"可见性 一个线程对共享变量的修改，另外一个线程能够立刻看到。 CPU缓存引起：CPU增加了缓存，以均衡与内存的速度差异导致。 ","date":"2018-04-01","objectID":"/javacurrent/:1:1","tags":["并发编程","大纲"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"原子性 一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 分时复用引起：操作系统增加了进程、线程，以分时复用CPU，进而均衡CPU与I/O设备的速度差异导致。 x = 10; //语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中 y = x; //语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。 x++; //语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。 x = x + 1; //语句4： 同语句3 ","date":"2018-04-01","objectID":"/javacurrent/:1:2","tags":["并发编程","大纲"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"有序性 程序执行的顺序按照代码的先后顺序执行。 重排序引起：由于编译程序指令重排序优化指令执行次序，使得缓存能够得到更加合理地利用导致。 ","date":"2018-04-01","objectID":"/javacurrent/:1:3","tags":["并发编程","大纲"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"线程安全的实现方法 ","date":"2018-04-01","objectID":"/javacurrent/:2:0","tags":["并发编程","大纲"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"互斥同步(阻塞同步) synchronized(JVM实现) Lock\u0026ReentrantLock(JDK实现) 互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。 互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。 ","date":"2018-04-01","objectID":"/javacurrent/:2:1","tags":["并发编程","大纲"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"非阻塞同步 CAS 随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。 这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。 乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。 硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，CAS)。 CAS指令需要有3个操作数，分别是内存地址V旧的预期值A和新值B。当执行操作时，只有当V的值等于A，才将V的值更新为B。 AtomicInteger J.U.C 包里面的整数原子类 AtomicInteger，其中的 compareAndSet() 和 getAndIncrement() 等方法都使用了 Unsafe 类的 CAS 操作。 public final int incrementAndGet() { return unsafe.getAndAddInt(this, valueOffset, 1) + 1; } public final int getAndAddInt(Object var1, long var2, int var4) { int var5; do { var5 = this.getIntVolatile(var1, var2); } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; } ABA 如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。 J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。 大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。 ","date":"2018-04-01","objectID":"/javacurrent/:2:2","tags":["并发编程","大纲"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"无需同步方案 栈封闭 多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。 线程本地存储(ThreadLocal) 如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。 符合这种特点的应用并不少见，大部分使用消费队列的架构模式(如“生产者-消费者”模式)都会将产品的消费过程尽量在一个线程中消费完。 其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”(Thread-per-Request)的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。 可重入代码 这种代码也叫做纯代码(Pure Code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。 可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。 ","date":"2018-04-01","objectID":"/javacurrent/:2:3","tags":["并发编程","大纲"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"解决并发 ","date":"2018-04-01","objectID":"/javacurrent/:3:0","tags":["并发编程","大纲"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"3个关键字 synchronized：原子性，可见性，有序性 volatile：有序性，可见性 防重排序 public class Singleton { public static volatile Singleton singleton; /** * 构造函数私有，禁止外部实例化 */ private Singleton() {}; public static Singleton getInstance() { if (singleton == null) { synchronized (singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } 现在我们分析一下为什么要在变量singleton之间加上volatile关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤： 分配内存空间。 初始化对象。 将内存空间的地址赋值给对应的引用。 但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程： 分配内存空间。 将内存空间的地址赋值给对应的引用。 初始化对象 如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。 实现可见性 volatile 变量的内存可见性是基于内存屏障(Memory Barrier)实现: 内存屏障，又称内存栅栏，是一个 CPU 指令。 在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止+ 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。 详细见：volatile理论基础 使用 volatile 必须具备的条件 对变量的写操作不依赖于当前值。 该变量没有包含在具有其他变量的不变式中。 只有在状态真正独立于程序内其他内容时才能使用volatile。 final：有序性 写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域就不具有这个保障。 读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读这个包含这个final域的对象的引用。 ","date":"2018-04-01","objectID":"/javacurrent/:3:1","tags":["并发编程","大纲"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"Happens-Before 规则 上面提到了可以用volatile和synchronized来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。 单一线程原则（在一个线程内，在程序前面的操作先行发生于后面的操作。） 管程锁定规则（一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。） volatile 变量规则（对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。） 线程启动规则（Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。） 线程加入规则（Thread 对象的结束先行发生于 join() 方法返回。） 线程中断规则（对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过interrupted()方法检测到是否有中断发生。） 对象终结规则 一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始。 传递性（如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。） ","date":"2018-04-01","objectID":"/javacurrent/:3:2","tags":["并发编程","大纲"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"锁优化及JMM 新的JDK优化锁的实现保证并发，内存模型也会保证可见性。 ","date":"2018-04-01","objectID":"/javacurrent/:3:3","tags":["并发编程","大纲"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"J.U.C框架 ","date":"2018-04-01","objectID":"/javacurrent/:4:0","tags":["并发编程","大纲"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"Unsafe(CAS)和原子类 ","date":"2018-04-01","objectID":"/javacurrent/:4:1","tags":["并发编程","大纲"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"AQS框架 AQS框架借助于两个类：Unsafe(提供CAS操作)和LockSupport(提供park/unpark操作)。 ","date":"2018-04-01","objectID":"/javacurrent/:4:2","tags":["并发编程","大纲"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"锁 LockSupport ReentrantLock ReentrantReadWriteLock ","date":"2018-04-01","objectID":"/javacurrent/:4:3","tags":["并发编程","大纲"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"并发集合 ConcurrentHashMap CopyOnWriteArrayList ConcurrentLinkedQueue BlockingQueue ","date":"2018-04-01","objectID":"/javacurrent/:4:4","tags":["并发编程","大纲"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"线程池 FutureTask ThreadPoolExecutor ScheduledThreadPoolExecutor Fork/Join ","date":"2018-04-01","objectID":"/javacurrent/:4:5","tags":["并发编程","大纲"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"工具类 CountDownLatch CyclicBarrier Semaphore Phaser Exchanger ThreadLocal ","date":"2018-04-01","objectID":"/javacurrent/:4:6","tags":["并发编程","大纲"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"参考文章 Java 并发 - 理论基础 ","date":"2018-04-01","objectID":"/javacurrent/:5:0","tags":["并发编程","大纲"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"HashMap详解","date":"2018-03-03","objectID":"/hashmap/","tags":["数据结构"],"title":"HashMap详解","uri":"/hashmap/"},{"categories":["Java基础"],"content":"实现步骤 HashMap基于哈希散列表，数组+链表/红黑树实现。 通过key的hashCode()方法计算出hashCode。 通过HashMap类中内部hash()方法将第2步中hashCode带入得出hash值。 通过第3步中hash值和HashMap中数组长度做\u0026(位运算)得出在数组中的位置。 当第4步中位置中没有值则直接放入。 当第4步中位置中有值即产生hash冲突问题，此时通过链表(拉链法)来解决hash冲突问题。 如果第6步中第链表大小超过阈值（TREEIFY_THRESHOLD,8），链表转换为红黑树。 在转换为红黑树时，会判断数组长度大于64才转换，否则继续采用扩容策略而不转换。 ","date":"2018-03-03","objectID":"/hashmap/:1:0","tags":["数据结构"],"title":"HashMap详解","uri":"/hashmap/"},{"categories":["Java基础"],"content":"关键特性 默认初始容量值为16，负载因子为0.75，当size\u003e=threshold（ threshold等于“容量负载因子”）时，会发生扩容：newsize = oldsize2，size一定为2的n次幂 hash冲突默认采用单链表存储，当单链表节点个数大于8时且数组长度大于64，会转化为红黑树存储， 当红黑树中节点少于6时，则转化为单链表存储。 扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入 当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀 ","date":"2018-03-03","objectID":"/hashmap/:2:0","tags":["数据结构"],"title":"HashMap详解","uri":"/hashmap/"},{"categories":["Java基础"],"content":"HashMap在1.7和1.8之间的变化： 1.7中是先扩容后插入新值的，1.8中是先插值再扩容 1.7中采用数组+链表，1.8采用的是数组+链表/红黑树，即在1.7中链表长度超过一定长度后就改成红黑树存储。 1.7扩容时需要重新计算哈希值和索引位置，1.8并不重新计算哈希值，巧妙地采用和扩容后容量进行\u0026操作来计算新的索引位置。 1.7是采用表头插入法插入链表，1.8采用的是尾部插入法。 在1.7中采用表头插入法，在扩容时会改变链表中元素原本的顺序，以至于在并发场景下导致链表成环的问题；在1.8中采用尾部插入法，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。 ","date":"2018-03-03","objectID":"/hashmap/:3:0","tags":["数据结构"],"title":"HashMap详解","uri":"/hashmap/"},{"categories":["Java基础"],"content":"方法（JDK1.8-数组+链表/红黑树） 确定哈希桶数组索引位置 第1步计算hash 在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h »\u003e 16)，主要是从速度、功效、质量来考虑的。 目的都是在数组很小也能降低hash碰撞。 static final int hash(Object key) { int h; // key.hashCode()：返回散列值也就是hashcode // ^ ：按位异或 // \u003e\u003e\u003e:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u003e\u003e\u003e 16); } 第2步计算数组位置 通过(n - 1) \u0026 hash来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方。 当length总是2的n次方时，h\u0026 (length-1)运算等价于对length取模，也就是h%length，但是\u0026(位运算)比%(取模运算)具有更高的效率。 (n - 1) \u0026 hash HashMap的put方法 public V put(K key, V value) { // 对key的hashCode()做hash return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e p; int n, i; // 步骤①：tab为空则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 步骤②：计算index，并对null做处理 if ((p = tab[i = (n - 1) \u0026 hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node\u003cK,V\u003e e; K k; // 步骤③：节点key存在，直接覆盖value if (p.hash == hash \u0026\u0026 ((k = p.key) == key || (key != null \u0026\u0026 key.equals(k)))) e = p; // 步骤④：判断该链为红黑树 else if (p instanceof TreeNode) e = ((TreeNode\u003cK,V\u003e)p).putTreeVal(this, tab, hash, key, value); // 步骤⑤：该链为链表 else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key,value,null); //链表长度大于8转换为红黑树进行处理 if (binCount \u003e= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } // key已经存在直接覆盖value if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; // 步骤⑥：超过最大容量 就扩容 if (++size \u003e threshold) resize(); afterNodeInsertion(evict); return null; } final void treeifyBin(Node\u003cK,V\u003e[] tab, int hash) { int n, index; Node\u003cK,V\u003e e; //树形化还有一个要求就是数组长度必须大于等于64，否则继续采用扩容策略 if (tab == null || (n = tab.length) \u003c MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) \u0026 hash]) != null) { TreeNode\u003cK,V\u003e hd = null, tl = null;//hd指向首节点，tl指向尾节点 do { TreeNode\u003cK,V\u003e p = replacementTreeNode(e, null);//将链表节点转化为红黑树节点 if (tl == null) // 如果尾节点为空，说明还没有首节点 hd = p; // 当前节点作为首节点 else { // 尾节点不为空，构造一个双向链表结构，将当前节点追加到双向链表的末尾 p.prev = tl; // 当前树节点的前一个节点指向尾节点 tl.next = p; // 尾节点的后一个节点指向当前节点 } tl = p; // 把当前节点设为尾节点 } while ((e = e.next) != null); // 继续遍历单链表 //将原本的单链表转化为一个节点类型为TreeNode的双向链表 if ((tab[index] = hd) != null) // 把转换后的双向链表，替换数组原来位置上的单向链表 hd.treeify(tab); // 将当前双向链表树形化 } } //将双向链表转化为红黑树的实现 final void treeify(Node\u003cK,V\u003e[] tab) { TreeNode\u003cK,V\u003e root = null; // 定义红黑树的根节点 for (TreeNode\u003cK,V\u003e x = this, next; x != null; x = next) { // 从TreeNode双向链表的头节点开始逐个遍历 next = (TreeNode\u003cK,V\u003e)x.next; // 头节点的后继节点 x.left = x.right = null; if (root == null) { x.parent = null; x.red = false; root = x; // 头节点作为红黑树的根，设置为黑色 } else { // 红黑树存在根节点 K k = x.key; int h = x.hash; Class\u003c?\u003e kc = null; for (TreeNode\u003cK,V\u003e p = root;;) { // 从根开始遍历整个红黑树 int dir, ph; K pk = p.key; if ((ph = p.hash) \u003e h) // 当前红黑树节点p的hash值大于双向链表节点x的哈希值 dir = -1; else if (ph \u003c h) // 当前红黑树节点的hash值小于双向链表节点x的哈希值 dir = 1; else if ((kc == null \u0026\u0026 (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) // 当前红黑树节点的hash值等于双向链表节点x的哈希值，则如果key值采用比较器一致则比较key值 dir = tieBreakOrder(k, pk); //如果key值也一致则比较className和identityHashCode TreeNode\u003cK,V\u003e xp = p; if ((p = (dir \u003c= 0) ? p.left : p.right) == null) { // 如果当前红黑树节点p是叶子节点，那么双向链表节点x就找到了插入的位置 x.parent = xp; if (dir \u003c= 0) //根据dir的值，插入到p的左孩子或者右孩子 xp.left = x; else xp.right = x; root = balanceInsertion(root, x); //红黑树中插入元素，需要进行平衡调整(过程和TreeMap调整逻辑一模一样) break; } } } } //将TreeNode双向链表转化为红黑树结构之后，由于红黑树是基于根节点进行查找，所以必须将红黑树的根节点作为数组当前位置的元素 moveRootToFront(tab, root); } //然后将红黑树的根节点移动端数组的索引所在位置上 static \u003cK,V\u003e void moveRootToFront(Node\u003cK,V\u003e[] tab, TreeNode\u003cK,V\u003e root) { int n; if (root != null \u0026\u0026 tab != null \u0026\u0026 (n = tab.length) \u003e 0) { int index = (n - 1) \u0026 root.hash; //找到红黑树根节点在数组中的位置 TreeNode\u003cK,V\u003e first = (TreeNode\u003cK,V\u003e)tab[inde","date":"2018-03-03","objectID":"/hashmap/:4:0","tags":["数据结构"],"title":"HashMap详解","uri":"/hashmap/"},{"categories":["Java基础"],"content":"参考文章 https://www.hollischuang.com/archives/2091 https://yuanrengu.com/2020/ba184259.html https://zhuanlan.zhihu.com/p/21673805 ","date":"2018-03-03","objectID":"/hashmap/:5:0","tags":["数据结构"],"title":"HashMap详解","uri":"/hashmap/"},{"categories":["Java基础"],"content":"ArrayList详解","date":"2018-03-02","objectID":"/arraylist/","tags":["数据结构"],"title":"ArrayList详解","uri":"/arraylist/"},{"categories":["Java基础"],"content":"ArrayList 简介 ArrayList 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用ensureCapacity操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。 ","date":"2018-03-02","objectID":"/arraylist/:1:0","tags":["数据结构"],"title":"ArrayList详解","uri":"/arraylist/"},{"categories":["Java基础"],"content":"ArrayList 核心源码解读 package java.util; import java.util.function.Consumer; import java.util.function.Predicate; import java.util.function.UnaryOperator; public class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e implements List\u003cE\u003e, RandomAccess, Cloneable, java.io.Serializable { private static final long serialVersionUID = 8683452581122892189L; /** * 默认初始容量大小 */ private static final int DEFAULT_CAPACITY = 10; /** * 空数组（用于空实例）。 */ private static final Object[] EMPTY_ELEMENTDATA = {}; //用于默认大小空实例的共享空数组实例。 //我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /** * 保存ArrayList数据的数组 */ transient Object[] elementData; // non-private to simplify nested class access /** * ArrayList 所包含的元素个数 */ private int size; /** * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小） */ public ArrayList(int initialCapacity) { if (initialCapacity \u003e 0) { //如果传入的参数大于0，创建initialCapacity大小的数组 this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { //如果传入的参数等于0，创建空数组 this.elementData = EMPTY_ELEMENTDATA; } else { //其他情况，抛出异常 throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); } } /** *默认无参构造函数 *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10 */ public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } /** * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。 */ public ArrayList(Collection\u003c? extends E\u003e c) { //将指定集合转换为数组 elementData = c.toArray(); //如果elementData数组的长度不为0 if ((size = elementData.length) != 0) { // 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断） if (elementData.getClass() != Object[].class) //将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组 elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // 其他情况，用空数组代替 this.elementData = EMPTY_ELEMENTDATA; } } /** * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。 */ public void trimToSize() { modCount++; if (size \u003c elementData.length) { elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); } } //下面是ArrayList的扩容机制 //ArrayList的扩容机制提高了性能，如果每次只扩充一个， //那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。 /** * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量 * @param minCapacity 所需的最小容量 */ public void ensureCapacity(int minCapacity) { //如果是true，minExpand的值为0，如果是false,minExpand的值为10 int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; //如果最小容量大于已有的最大容量 if (minCapacity \u003e minExpand) { ensureExplicitCapacity(minCapacity); } } //得到最小扩容量 private void ensureCapacityInternal(int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { // 获取“默认的容量”和“传入参数”两者之间的最大值 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); } ensureExplicitCapacity(minCapacity); } //判断是否需要扩容 private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length \u003e 0) //调用grow方法进行扩容，调用此方法代表已经开始扩容了 grow(minCapacity); } /** * 要分配的最大数组大小 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * ArrayList扩容的核心方法。 */ private void grow(int minCapacity) { // oldCapacity为旧容量，newCapacity为新容量 int oldCapacity = elementData.length; //将oldCapacity 右移一位，其效果相当于oldCapacity /2， //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍， int newCapacity = oldCapacity + (oldCapacity \u003e\u003e 1); //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量， if (newCapacity - minCapacity \u003c 0) newCapacity = minCapacity; //再检查新容量是否超出了ArrayList所定义的最大容量， //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE， //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。 if (newCapacity - MAX_ARRAY_SIZE \u003e 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } //比较minCapacity和 MAX_ARRAY_SIZE private static int hug","date":"2018-03-02","objectID":"/arraylist/:2:0","tags":["数据结构"],"title":"ArrayList详解","uri":"/arraylist/"},{"categories":["Java基础"],"content":"Java容器","date":"2018-03-01","objectID":"/javacontainer/","tags":["数据结构","大纲"],"title":"Java容器概览","uri":"/javacontainer/"},{"categories":["Java基础"],"content":"概览 容器主要包括Collection和Map 两种，Collection存储着对象的集合，而Map存储着键值对（两个对象）的映射表。 ","date":"2018-03-01","objectID":"/javacontainer/:1:0","tags":["数据结构","大纲"],"title":"Java容器概览","uri":"/javacontainer/"},{"categories":["Java基础"],"content":"Collection ","date":"2018-03-01","objectID":"/javacontainer/:2:0","tags":["数据结构","大纲"],"title":"Java容器概览","uri":"/javacontainer/"},{"categories":["Java基础"],"content":"List 对付顺序的好帮手： 存储的元素是有序的、可重复的。 ArrayList：基于动态数组实现，支持随机访问，适用于频繁的查找工作。 Vector：和ArrayList类似，但它是线程安全的。 LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList还可以用作栈、队列和双向队列。 Arraylist与 LinkedList 区别? 是否保证线程安全： ArrayList和LinkedList都是不同步的，也就是不保证线程安全； 底层数据结构： Arraylist底层使用的是Object数组；LinkedList底层使用的是双向链表数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。） 插入和删除是否受元素位置的影响： ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 LinkedList 采用链表存储，所以对于add(E e)方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置 i 插入和删除元素的话（(add(int index, E element)） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。 是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。 内存空间占用： ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。 ","date":"2018-03-01","objectID":"/javacontainer/:2:1","tags":["数据结构","大纲"],"title":"Java容器概览","uri":"/javacontainer/"},{"categories":["Java基础"],"content":"Set 注重独一无二的性质: 存储的元素是无序的、不可重复的。 HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。基于 HashMap 实现的，底层采用 HashMap 来保存元素。 LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。LinkedHashSet 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。 TreeSet：基于红黑树实现（(自平衡的排序二叉树)），支持有序性操作，例如根据一个范围查找元素的操作。查找效率不如HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 HashSet 如何检查重复 当你把对象加入HashSet时，HashSet 会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。 hashCode()与 equals() 的相关规定： 如果两个对象相等，则 hashcode 一定也是相同的 两个对象相等,对两个 equals() 方法返回 true 两个对象有相同的 hashcode 值，它们也不一定是相等的 综上，equals() 方法被覆盖过，则 hashCode() 方法也必须被覆盖 hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。 ","date":"2018-03-01","objectID":"/javacontainer/:2:2","tags":["数据结构","大纲"],"title":"Java容器概览","uri":"/javacontainer/"},{"categories":["Java基础"],"content":"Queue LinkedList：可以用它来实现双向队列。 PriorityQueue：基于堆结构实现，可以用它来实现优先队列。 ","date":"2018-03-01","objectID":"/javacontainer/:2:3","tags":["数据结构","大纲"],"title":"Java容器概览","uri":"/javacontainer/"},{"categories":["Java基础"],"content":"Map 用 Key 来搜索的专家: 使用键值对（key-value）存储，Key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。 TreeMap： 红黑树（自平衡的排序二叉树） HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高。 LinkedHashMap：LinkedHashMap 继承自 HashMap，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。 ","date":"2018-03-01","objectID":"/javacontainer/:3:0","tags":["数据结构","大纲"],"title":"Java容器概览","uri":"/javacontainer/"},{"categories":["Java基础"],"content":"如何选择 主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 Map 接口下的集合，需要排序时选择 TreeMap,不需要排序时就选择 HashMap,需要保证线程安全就选用 ConcurrentHashMap。 当我们只需要存放元素值时，就选择实现Collection 接口的集合，需要保证元素唯一时选择实现 Set 接口的集合比如 TreeSet 或 HashSet，不需要就选择实现 List 接口的比如 ArrayList 或 LinkedList，然后再根据实现这些接口的集合的特点来选用。 ","date":"2018-03-01","objectID":"/javacontainer/:4:0","tags":["数据结构","大纲"],"title":"Java容器概览","uri":"/javacontainer/"},{"categories":["Java基础"],"content":"为什么要使用 当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端，因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。 数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。 但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。 ","date":"2018-03-01","objectID":"/javacontainer/:5:0","tags":["数据结构","大纲"],"title":"Java容器概览","uri":"/javacontainer/"},{"categories":["Java基础"],"content":"反射让一切有了可能","date":"2018-02-03","objectID":"/reflection/","tags":["Java基础"],"title":"框架的灵魂-反射","uri":"/reflection/"},{"categories":["Java基础"],"content":"什么是反射 简而言之，通过反射，我们可以在运行时获得程序中每一个类型的成员和成员的信息。 程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。 所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。 反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。 ","date":"2018-02-03","objectID":"/reflection/:1:0","tags":["Java基础"],"title":"框架的灵魂-反射","uri":"/reflection/"},{"categories":["Java基础"],"content":"Java 反射主要提供以下功能 在运行时构造任意一个类的对象。 在运行时调用任意一个对象的方法。 在运行时判断任意一个对象所属的类。 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）。 ","date":"2018-02-03","objectID":"/reflection/:1:1","tags":["Java基础"],"title":"框架的灵魂-反射","uri":"/reflection/"},{"categories":["Java基础"],"content":"反射的主要用途 反射最重要的用途就是开发各种通用框架。 很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。 举一个例子，在运用 Struts 2 框架的开发中我们一般会在 struts.xml 里去配置 Action，比如： \u003caction name=\"login\" class=\"org.ScZyhSoft.test.action.SimpleLoginAction\" method=\"execute\"\u003e \u003cresult\u003e/shop/shop-index.jsp\u003c/result\u003e \u003cresult name=\"error\"\u003elogin.jsp\u003c/result\u003e \u003c/action\u003e 配置文件与 Action 建立了一种映射关系，当 View 层发出请求时，请求会被 StrutsPrepareAndExecuteFilter 拦截，然后 StrutsPrepareAndExecuteFilter 会去动态地创建 Action 实例。比如我们请求 login.action，那么 StrutsPrepareAndExecuteFilter就会去解析struts.xml文件，检索action中name为login的Action，并根据class属性创建SimpleLoginAction实例，并用invoke方法来调用execute方法，这个过程离不开反射。 对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。 像Java中的一大利器注解的实现也用到了反射。 为什么你使用 Spring 的时候 ，一个@Component注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 @Value注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？ 这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。 ","date":"2018-02-03","objectID":"/reflection/:2:0","tags":["Java基础"],"title":"框架的灵魂-反射","uri":"/reflection/"},{"categories":["Java基础"],"content":"反射的基本运用 ","date":"2018-02-03","objectID":"/reflection/:3:0","tags":["Java基础"],"title":"框架的灵魂-反射","uri":"/reflection/"},{"categories":["Java基础"],"content":"获得Class对象 使用Class类的forName 静态方法。 Class appleClass = Class.forName(\"base.reflection.Apple\"); 直接获取 Class appleClass = Apple.class; 获取某一个对象的class Apple apple = new Apple(); Class appleClass = apple.getClass(); 通过类加载器ClassLoader.loadClass()传入类路径获取 Class appleClass = ClassLoader.getSystemClassLoader().loadClass(\"base.reflection.Apple\"); ","date":"2018-02-03","objectID":"/reflection/:3:1","tags":["Java基础"],"title":"框架的灵魂-反射","uri":"/reflection/"},{"categories":["Java基础"],"content":"构造方法 Constructor[] declaredConstructors = appleClass.getDeclaredConstructors(); Constructor[] constructors = appleClass.getConstructors(); //通过无参构造来获取该类对象 newInstance() Apple apple= (Apple)appleClass.newInstance(); //通过有参构造来获取该类对象 newInstance Constructor constructor = appleClass.getConstructor(String.class,int.class,int.class); Apple apple=(Apple)constructor.newInstance(\"红色\",10,5); ","date":"2018-02-03","objectID":"/reflection/:3:2","tags":["Java基础"],"title":"框架的灵魂-反射","uri":"/reflection/"},{"categories":["Java基础"],"content":"属性 //getDeclaredFields所有已声明的成员变量，但不能得到其父类的成员变量 Field[] declaredFields = appleClass.getDeclaredFields(); //getFields访问公有的成员变量 Field[] fields = appleClass.getFields(); ","date":"2018-02-03","objectID":"/reflection/:3:3","tags":["Java基础"],"title":"框架的灵魂-反射","uri":"/reflection/"},{"categories":["Java基础"],"content":"方法 //getDeclaredMethods 方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 Method[] declaredMethods = appleClass.getDeclaredMethods(); //getMethods方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。 Method[] methods = appleClass.getMethods(); ","date":"2018-02-03","objectID":"/reflection/:3:4","tags":["Java基础"],"title":"框架的灵魂-反射","uri":"/reflection/"},{"categories":["Java基础"],"content":"调用方法 Constructor constructor = appleClass.getConstructor(String.class,int.class,int.class); Apple apple = (Apple)constructor.newInstance(\"红色\",10,5); //获取toString方法并调用 Method method = appleClass.getDeclaredMethod(\"toString\"); String str = (String)method.invoke(apple); System.out.println(str); ","date":"2018-02-03","objectID":"/reflection/:3:5","tags":["Java基础"],"title":"框架的灵魂-反射","uri":"/reflection/"},{"categories":["Java基础"],"content":"利用反射创建数组 Class\u003c?\u003e cls = Class.forName(\"java.lang.String\"); Object array = Array.newInstance(cls,5); //往数组里添加内容 Array.set(array,0,\"hello\"); Array.set(array,1,\"Java\"); Array.set(array,2,\"fuck\"); Array.set(array,3,\"Scala\"); Array.set(array,4,\"Clojure\"); //获取某一项的内容 System.out.println(Array.get(array,3)); ","date":"2018-02-03","objectID":"/reflection/:3:6","tags":["Java基础"],"title":"框架的灵魂-反射","uri":"/reflection/"},{"categories":["Java基础"],"content":"参数化类型","date":"2018-02-02","objectID":"/generic/","tags":["Java基础"],"title":"Java特性-泛型","uri":"/generic/"},{"categories":["Java基础"],"content":"泛型，即参数化类型。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。 那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（类型形参），然后在使用/调用时传入具体的类型（类型实参）。 Java 语言中引入泛型是一个较大的功能增强。不仅语言、类型系统和编译器有了较大的变化，而且类库也进行了大翻修，所以许多重要的类，比如集合框架，都已经成为泛型化的了。这带来了很多好处： 类型安全。 泛型的主要目标是提高 Java 程序的类型安全。通过知道使用泛型定义的变量的类型限制，编译器可以在一个高得多的程度上验证类型假设。 消除强制类型转换。 泛型的一个附带好处是，消除源代码中的许多强制类型转换。这使得代码更加可读，并且减少了出错机会。 潜在的性能收益。 泛型为较大的优化带来可能。在泛型的初始实现中，编译器将强制类型转换（没有泛型的话，程序员会指定这些强制类型转换）插入生成的字节码中。 注意泛型的类型参数只能是类类型（包括自定义类），不能是简单类型。 ","date":"2018-02-02","objectID":"/generic/:0:0","tags":["Java基础"],"title":"Java特性-泛型","uri":"/generic/"},{"categories":["Java基础"],"content":"常用命名类型参数 K：键，比如映射的键 V：值，比如 List 和 Set 的内容，或者 Map 中的值 E：元素 T：泛型 ?：表示不确定的 java 类型 ","date":"2018-02-02","objectID":"/generic/:0:1","tags":["Java基础"],"title":"Java特性-泛型","uri":"/generic/"},{"categories":["Java基础"],"content":"通配符 Ingeter 是 Number 的一个子类，同时 Generic 与 Generic 实际上是相同的一种基本类型。那么问题来了，在使用 Generic 作为形参的方法中，能否使用Generic 的实例传入呢？在逻辑上类似于 Generic 和 Generic 是否可以看成具有父子关系的泛型类型呢？下面我们通过定义一个方法来验证。 public void show(Generic\u003cNumber\u003e obj) { System.out.println(\"key value is \" + obj.getKey()); } 进行如下的调用： Generic\u003cInteger\u003e genericInteger = new Generic\u003cInteger\u003e(123); show(genericInteger); //error Generic\u003cjava.lang.Integer\u003e cannot be applied to Generic\u003cjava.lang.Number\u003e 通过提示信息我们可以看到 Generic 不能被看作为 Generic 的子类。由此可以看出：同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。 我们不能因此定义一个 show(Generic obj)来处理，因此我们需要一个在逻辑上可以表示同时是Generic和Generic父类的引用类型。由此类型通配符应运而生。 T、K、V、E 等泛型字母为有类型，类型参数赋予具体的值。除了有类型，还可以用通配符来表述类型，？ 未知类型，类型参数赋予不确定值，任意类型只能用在声明类型、方法参数上，不能用在定义泛型类上。将方法改写成如下： public void show(Generic\u003c?\u003e obj) { System.out.println(\"key value is \" + obj.getKey()); } 此处 ? 是类型实参，而不是类型形参。即和 Number、String、Integer 一样都是实际的类型，可以把 ？ 看成所有类型的父类，是一种真实的类型。可以解决当具体类型不确定的时候，这个通配符就是 ?；当操作类型时，不需要使用类型的具体功能时，只使用 Object 类中的功能。那么可以用 ? 通配符来表未知类型。 ","date":"2018-02-02","objectID":"/generic/:0:2","tags":["Java基础"],"title":"Java特性-泛型","uri":"/generic/"},{"categories":["Java基础"],"content":"泛型上下边界 通配符上限为：Generic\u003c? extends Number\u003e 通配符下限为：Generic\u003c? super Number\u003e 在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。为泛型添加上边界，即传入的类型实参必须是指定类型的子类型。 public void show(Generic\u003c? extends Number\u003e obj) { System.out.println(\"key value is \" + obj.getKey()); } 我们在泛型方法的入参限定参数类型为 Number 的子类。 Generic\u003cString\u003e genericString = new Generic\u003cString\u003e(\"11111\"); Generic\u003cInteger\u003e genericInteger = new Generic\u003cInteger\u003e(2222); showKeyValue1(genericString); // error showKeyValue1(genericInteger); 当我们的入参为 String 类型时，编译报错，因为 String 类型并不是 Number 类型的子类。 类型通配符上限通过形如 Generic\u003c? extends Number\u003e 形式定义；相对应的，类型通配符下限为Generic\u003c? super Number\u003e形式，其含义与类型通配符上限正好相反，在此不作过多阐述。 ","date":"2018-02-02","objectID":"/generic/:0:3","tags":["Java基础"],"title":"Java特性-泛型","uri":"/generic/"},{"categories":["Java基础"],"content":"一个泛型的增删改查Service @Transactional(readOnly = true) public abstract class CrudService\u003cD extends CrudDao\u003cT\u003e, T extends DataEntity\u003cT\u003e\u003e extends BaseService { /** * 持久层对象 */ @Autowired protected D dao; /** * 获取单条数据 * @param entity * @return */ public T get(T entity) { return dao.get(entity); } /** * 查询列表数据 * @param entity * @return */ public List\u003cT\u003e findList(T entity) { return dao.findList(entity); } /** * 查询分页数据 * @param page 分页对象 * @param entity * @return */ public Page\u003cT\u003e findPage(Page\u003cT\u003e page, T entity) { entity.setPage(page); page.setList(dao.findList(entity)); return page; } /** * 保存数据（插入或更新） * @param entity */ @Transactional(readOnly = false) public int save(T entity) { if (entity.getIsNewRecord()){ entity.preInsert(); return dao.insert(entity); }else{ entity.preUpdate(); return dao.update(entity); } } /** * 删除数据 * @param entity */ @Transactional(readOnly = false) public int delete(T entity) { return dao.delete(entity); } } ","date":"2018-02-02","objectID":"/generic/:0:4","tags":["Java基础"],"title":"Java特性-泛型","uri":"/generic/"},{"categories":["Java基础"],"content":"面向对象的三大法宝和七大戒律","date":"2018-02-01","objectID":"/object-oriented/","tags":["Java基础"],"title":"Java世界的入场券-面向对象","uri":"/object-oriented/"},{"categories":["Java基础"],"content":" 面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的编程典范，同时也是一种程序开发的抽象方针。它可能包含数据、特性、代码与方法。对象则指的是类（class）的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。 面向对象就像是一张入场券，掌握了面向对象的思想，就可以在Java世界里尽情遨游，面向对象有三大法宝和七大戒律，并在其指导下萃取出了无数的锦囊妙计和绝世武器，下面我们揭开他们的神秘面纱。 ","date":"2018-02-01","objectID":"/object-oriented/:0:0","tags":["Java基础"],"title":"Java世界的入场券-面向对象","uri":"/object-oriented/"},{"categories":["Java基础"],"content":"OOP（面向对象编程）的三大法宝 封装 封装，也就是把客观事物封装成抽象的类，并且类可以把自己的属性和方法只让可信的类操作，对不可信的类进行信息隐藏。 继承 继承是指这样一种能力，它可以使用现有的类的所有功能，并在无需重新编写原来类的情况下对这些功能进行扩展。 多态 多态指一个类实例的相同方法在不同情形有不同的表现形式。具体来说就是不同实现类对公共接口有不同的实现方式，但这些操作可以通过相同的方式（公共接口）予以调用。 ","date":"2018-02-01","objectID":"/object-oriented/:0:1","tags":["Java基础"],"title":"Java世界的入场券-面向对象","uri":"/object-oriented/"},{"categories":["Java基础"],"content":"OOD（面向对象设计）七大戒律 开-闭原则 Open-Close Principle（OCP），即开-闭原则。开，指的是对扩展开放，即要支持方便地扩展；闭，指的是对修改关闭，即要严格限制对已有内容的修改。开-闭原则是最抽象也是最重要的OOD原则。简单工厂模式、工厂方法模式、抽象工厂模式中都提到了如何通过良好的设计遵循开-闭原则。 里氏替换原则 Liskov Substitution Principle（LSP），即里氏替换原则。该原则规定“子类必须能够替换其父类，否则不应当设计为其子类”。换句话说，父类出现的地方，都应该能由其子类代替。所以，子类只能去扩展基类，而不是隐藏或者覆盖基类。 依赖倒置原则 Dependence Inversion Principle（DIP），依赖倒置原则。它讲的是“设计和实现要依赖于抽象而非具体”。一方面抽象化更符合人的思维习惯；另一方面，根据里氏替换原则，可以很容易将原来的抽象替换为扩展后的具体，这样可以很好的支持开-闭原则。 接口隔离原则 Interface Segration Principle（ISP），接口隔离原则，“将大的接口打散成多个小的独立的接口”。由于Java类支持实现多个接口，可以很容易的让类具有多种接口的特征，同时每个类可以选择性地只实现目标接口。 单一职责原则 Single Responsibility Principle（SRP），单一职责原则。它讲的是，不要存在多于一个导致类变更的原因，是高内聚低耦合的一个体现。 迪米特法则/最少知道原则 Law of Demeter or Least Knowledge Principle（LoD or LKP），迪米特法则或最少知道原则。它讲的是“一个对象就尽可能少的去了解其它对象”，从而实现松耦合。如果一个类的职责过多，由于多个职责耦合在了一起，任何一个职责的变更都可能引起其它职责的问题，严重影响了代码的可维护性和可重用性。 合成/聚合复用原则 Composite/Aggregate Reuse Principle（CARP / CRP），合成/聚合复用原则。如果新对象的某些功能在别的已经创建好的对象里面已经实现，那么应当尽量使用别的对象提供的功能，使之成为新对象的一部分，而不要再重新创建。新对象可通过向这些对象的委派达到复用已有功能的效果。简而言之，要尽量使用合成/聚合，而非使用继承。《Java设计模式（九） 桥接模式》中介绍的桥接模式即是对这一原则的典型应用。 ","date":"2018-02-01","objectID":"/object-oriented/:0:2","tags":["Java基础"],"title":"Java世界的入场券-面向对象","uri":"/object-oriented/"},{"categories":["Java基础"],"content":"行走江湖的锦囊妙计和绝世武器 上面的法宝和戒律是心法，真正行走江湖还需要趁手的兵器和锦囊妙计。 而设计模式就是应用三大法宝和七大戒律下经过反复实践铸造出来锦囊妙计和武器，具体有哪些武器我们暂且不表，毕竟倚天屠龙出世，江湖必将血雨腥风，在这之前我们还需要做好准备工作。 ","date":"2018-02-01","objectID":"/object-oriented/:0:3","tags":["Java基础"],"title":"Java世界的入场券-面向对象","uri":"/object-oriented/"},{"categories":["数据结构"],"content":"散列是数组和链表的结合体","date":"2017-02-03","objectID":"/hashtable/","tags":["数据结构"],"title":"哈希表","uri":"/hashtable/"},{"categories":["数据结构"],"content":"定义 散列Hash是和顺序、链接和索引一样，是存储集合或者线性表的一种方法。 散列的基本思想是：以集合或线性表中的每个元素的关键字K为自变量，通过一个散列函数 h(K) 得到的结果，将这个结果解释为一块连续的存储空间（如数组）的地址（如数组下标），将这个元素存储到这个空间中。 h(K) 称为散列函数或者哈希函数，它实现了关键字到存储地址的映射，散列算法，变换成固定长度的输出，该输出就是散列值。h(K)的值 称为散列地址或者哈希地址。存储空间是线性表进行散列存储的空间，所以称之为散列表或者哈希表。 ","date":"2017-02-03","objectID":"/hashtable/:1:0","tags":["数据结构"],"title":"哈希表","uri":"/hashtable/"},{"categories":["数据结构"],"content":"释义 这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 所有散列函数都有如下一个基本特性：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。 两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做碰撞，衡量一个哈希函数的好坏的重要指标就是发生碰撞的概率以及发生碰撞的解决方案。 ","date":"2017-02-03","objectID":"/hashtable/:2:0","tags":["数据结构"],"title":"哈希表","uri":"/hashtable/"},{"categories":["数据结构"],"content":"常见的Hash函数 直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址。 数字分析法：提取关键字中取值比较均匀的数字作为哈希地址。 除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址。 分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。 平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。 伪随机数法：采用一个伪随机数当作哈希函数。 ","date":"2017-02-03","objectID":"/hashtable/:3:0","tags":["数据结构"],"title":"哈希表","uri":"/hashtable/"},{"categories":["数据结构"],"content":"解决碰撞方法 开放定址法：开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。 链地址法：将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。 再哈希法：当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。 建立公共溢出区：将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。 ","date":"2017-02-03","objectID":"/hashtable/:4:0","tags":["数据结构"],"title":"哈希表","uri":"/hashtable/"},{"categories":["数据结构"],"content":"散列存储的缺点 计算散列地址需要花费时间，关键字不是整数还先要转换为整数。 占用更多的存储空间，开放定址法的装载因子小于1，链接法则需要空间存储指针。 只能按关键字查找，无法按非关键字查找。 ","date":"2017-02-03","objectID":"/hashtable/:5:0","tags":["数据结构"],"title":"哈希表","uri":"/hashtable/"},{"categories":["数据结构"],"content":"数组是用于储存多个相同类型数据的集合","date":"2017-02-02","objectID":"/linkedlist/","tags":["数据结构"],"title":"链表","uri":"/linkedlist/"},{"categories":["数据结构"],"content":"定义 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 ","date":"2017-02-02","objectID":"/linkedlist/:1:0","tags":["数据结构"],"title":"链表","uri":"/linkedlist/"},{"categories":["数据结构"],"content":"详解 链表的存在就是为了解决数组的增删复杂耗时，内存占用较大的问题。它并不需要一块连续的内存空间，它通过指针将一组零散的内存块串联起来。 根据指针的不同，有单链表，双向链表，循环链表之分。 数组和链表是相互补充的一对数据结构。 ","date":"2017-02-02","objectID":"/linkedlist/:2:0","tags":["数据结构"],"title":"链表","uri":"/linkedlist/"},{"categories":["数据结构"],"content":"优点： 操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。 链表因为元素不连续，而是靠指针指向下一个元素的位置，本身没有大小的限制，不存在数组的扩容问题，所以天然地支持动态扩容。 ","date":"2017-02-02","objectID":"/linkedlist/:3:0","tags":["数据结构"],"title":"链表","uri":"/linkedlist/"},{"categories":["数据结构"],"content":"缺点： 因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问。 由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。 同时内存不连续，容易造成内存碎片。 ","date":"2017-02-02","objectID":"/linkedlist/:4:0","tags":["数据结构"],"title":"链表","uri":"/linkedlist/"},{"categories":["数据结构"],"content":"对比 ","date":"2017-02-02","objectID":"/linkedlist/:5:0","tags":["数据结构"],"title":"链表","uri":"/linkedlist/"},{"categories":["数据结构"],"content":"数组 数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难。 ","date":"2017-02-02","objectID":"/linkedlist/:5:1","tags":["数据结构"],"title":"链表","uri":"/linkedlist/"},{"categories":["数据结构"],"content":"链表 链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：寻址困难，插入和删除容易。 ","date":"2017-02-02","objectID":"/linkedlist/:5:2","tags":["数据结构"],"title":"链表","uri":"/linkedlist/"},{"categories":["数据结构"],"content":"哈希表 那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？这就是我们要提起的哈希表。 ","date":"2017-02-02","objectID":"/linkedlist/:5:3","tags":["数据结构"],"title":"链表","uri":"/linkedlist/"},{"categories":["数据结构"],"content":"数组是用于储存多个相同类型数据的集合","date":"2017-02-01","objectID":"/array/","tags":["数据结构"],"title":"数组","uri":"/array/"},{"categories":["数据结构"],"content":"定义 有限个相同数据类型的元素按顺序排列的集合为数组。 ","date":"2017-02-01","objectID":"/array/:1:0","tags":["数据结构"],"title":"数组","uri":"/array/"},{"categories":["数据结构"],"content":"特性 数组是相同数据类型的元素的集合。 数组中的各元素的存储是有先后顺序的，它们在内存中按照这个先后顺序连续存放在一起。 ","date":"2017-02-01","objectID":"/array/:2:0","tags":["数据结构"],"title":"数组","uri":"/array/"},{"categories":["数据结构"],"content":"优点： 由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间，查询修改元素的效率O(1)。 ","date":"2017-02-01","objectID":"/array/:3:0","tags":["数据结构"],"title":"数组","uri":"/array/"},{"categories":["数据结构"],"content":"缺点： 正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)。 想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N) ","date":"2017-02-01","objectID":"/array/:4:0","tags":["数据结构"],"title":"数组","uri":"/array/"},{"categories":["数据结构"],"content":"二维数组 二维数组也称为矩阵，因为是二维的，所以需要两个下标才能确定一个元素，即行下标和列下标。 ","date":"2017-02-01","objectID":"/array/:5:0","tags":["数据结构"],"title":"数组","uri":"/array/"},{"categories":["理财"],"content":"投资纲领","date":"2016-01-01","objectID":"/investment/","tags":["理财"],"title":"投资纲领","uri":"/investment/"},{"categories":["理财"],"content":"总体策略 低估加倍 高估不买 高估卖出 好资产 + 好价格 + 长期持有 ","date":"2016-01-01","objectID":"/investment/:1:0","tags":["理财"],"title":"投资纲领","uri":"/investment/"},{"categories":["理财"],"content":"资产配置 ","date":"2016-01-01","objectID":"/investment/:2:0","tags":["理财"],"title":"投资纲领","uri":"/investment/"},{"categories":["理财"],"content":"购买标的 ","date":"2016-01-01","objectID":"/investment/:3:0","tags":["理财"],"title":"投资纲领","uri":"/investment/"},{"categories":["理财"],"content":"宽基指数（沪深300和中证500） 我们可以把沪深300和中证500这样的宽基指数作为「核心」资产，比如占整体仓位的 60% 以上，保证我们能够跟上中国经济的增长，投资到未来头部的公司。 40% 基于估值和增强型指数基金进一步提高仓位。 ","date":"2016-01-01","objectID":"/investment/:3:1","tags":["理财"],"title":"投资纲领","uri":"/investment/"},{"categories":["理财"],"content":"「卫星」资产 我们可以根据自己的判断或者市场的估值，加入一部分「卫星」资产。 主动基金（优秀基金精力管理的基金）中概互联基金 科创板（还需观看） 。 30% 分散投资给几个优秀的主动型基金经理。 ","date":"2016-01-01","objectID":"/investment/:3:2","tags":["理财"],"title":"投资纲领","uri":"/investment/"},{"categories":["理财"],"content":"债券 30% 的债券仓位，用债券基金以及有知有行未来推荐的其它「固收+」产品来进一步提高收益。 计算得出年化收益率：40% * 13% + 30% * 11% + 30% * 4% + 1% = 10.7%。 ","date":"2016-01-01","objectID":"/investment/:3:3","tags":["理财"],"title":"投资纲领","uri":"/investment/"},{"categories":["理财"],"content":"具体操作 ","date":"2016-01-01","objectID":"/investment/:4:0","tags":["理财"],"title":"投资纲领","uri":"/investment/"},{"categories":["理财"],"content":"每年一次大额买入 参考有知有行的「股市温度计」来确定自己一次性买入的仓位。 假如当年大额资金5万，当时股市温度为40处于中估状态，则先投入50%，计算得出当年大额买入资金为2.5万。 ","date":"2016-01-01","objectID":"/investment/:4:1","tags":["理财"],"title":"投资纲领","uri":"/investment/"},{"categories":["理财"],"content":"每年一次的再平衡 根据自定的家庭资产比例和当年股债实时状态，进行股债再平衡调整。 ","date":"2016-01-01","objectID":"/investment/:4:2","tags":["理财"],"title":"投资纲领","uri":"/investment/"},{"categories":["理财"],"content":"每月定投 参考有知有行的「股市温度计」，在中估时投入，低估时加倍，高估时停止买入 ","date":"2016-01-01","objectID":"/investment/:4:3","tags":["理财"],"title":"投资纲领","uri":"/investment/"},{"categories":["理财"],"content":"高估状态卖出部分锁定收益 A股的波动大，牛市之后往往出现暴跌，而浮亏越大，回本难度越大，甚至难度是呈指数级增长的。 ","date":"2016-01-01","objectID":"/investment/:4:4","tags":["理财"],"title":"投资纲领","uri":"/investment/"},{"categories":["反思"],"content":"写作促进思考","date":"2015-01-02","objectID":"/studyandthink/","tags":["反思"],"title":"学与思","uri":"/studyandthink/"},{"categories":["反思"],"content":"学而不思则罔，思而不学则殆 一味学习而不思考，就会因为不能深刻理解而不能合理有效利用学习的知识，甚至会陷入迷茫。 一味空想而不去进行实实在在地学习和钻研，则终究是沙上建塔，一无所得。 因此我们只有把学习和思考结合起来，才能学到切实有用的知识，否则就会收效甚微。 ","date":"2015-01-02","objectID":"/studyandthink/:0:1","tags":["反思"],"title":"学与思","uri":"/studyandthink/"},{"categories":["记录"],"content":"Markdown常用语法","date":"2015-01-01","objectID":"/mdgrammar/","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"标题 #### 这是 H5 #### 这是 H5 ","date":"2015-01-01","objectID":"/mdgrammar/:0:1","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"段落 这是一个段落。 这是另一个段落。 这是一个段落。 这是另一个段落。 ","date":"2015-01-01","objectID":"/mdgrammar/:0:2","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"斜体 *这是斜体* 这是斜体 ","date":"2015-01-01","objectID":"/mdgrammar/:0:3","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"粗体 **这是粗体** 这是粗体 ","date":"2015-01-01","objectID":"/mdgrammar/:0:4","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"粗体+斜体 ***这是粗体+斜体*** 这是粗体+斜体 ","date":"2015-01-01","objectID":"/mdgrammar/:0:5","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"删除线 ~~没有价值就会被抛弃~~ 没有价值就会被抛弃 ","date":"2015-01-01","objectID":"/mdgrammar/:0:6","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"引用 \u003e Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 ","date":"2015-01-01","objectID":"/mdgrammar/:0:7","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"列表 * 学习 * 思考 * 创造 学习 思考 创造 ","date":"2015-01-01","objectID":"/mdgrammar/:0:8","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"有序列表 1. 昨夜西风凋碧树。独上高楼，望尽天涯路。 2. 衣带渐宽终不悔，为伊消得人憔悴。 3. 众里寻他千百度。蓦然回首，那人却在，灯火阑珊处。 昨夜西风凋碧树。独上高楼，望尽天涯路。 衣带渐宽终不悔，为伊消得人憔悴。 众里寻他千百度。蓦然回首，那人却在，灯火阑珊处。 ","date":"2015-01-01","objectID":"/mdgrammar/:0:9","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"分隔线 --------------------------------------- ","date":"2015-01-01","objectID":"/mdgrammar/:0:10","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"链接 [百度](http://www.baidu.com/ \"百度一下\") 百度 ","date":"2015-01-01","objectID":"/mdgrammar/:0:11","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"表格 | 账户 | 余额 | 类别 | | :------- | ----: | :---: | | 人民币 | 5百万 | 活期 | | 比特币 | 5个 | 数字资产 | | 股票基金 | 5亿 | 理财 | 账户 余额 类别 人民币 5百万 活期 比特币 5个 数字资产 股票基金 5亿 理财 ","date":"2015-01-01","objectID":"/mdgrammar/:0:12","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"代码区域（四个空格） /** 这是一个Java代码区块 */ public static void main(String[] args) { System.out.println(\"Hello World\"); } ","date":"2015-01-01","objectID":"/mdgrammar/:0:13","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"图像 ![](/images/star.png \"星辰大海\") 星辰大海 ","date":"2015-01-01","objectID":"/mdgrammar/:0:14","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["反思"],"content":"舒缓生活","date":"2015-01-01","objectID":"/energy/","tags":["生活"],"title":"减缓焦虑，积聚生活正能量","uri":"/energy/"},{"categories":["反思"],"content":" 面对不断袭来的压力和信息，我们要做的，就是找到自己的节奏，建立一套稳定的模式，用来应对和处理种种事务。尽可能让一切「平稳」下来。 这也许需要一些取舍，一些选择、牺牲和放弃 —— 但一旦这套模式能够建立起来，一切都是值得的。 ","date":"2015-01-01","objectID":"/energy/:0:0","tags":["生活"],"title":"减缓焦虑，积聚生活正能量","uri":"/energy/"},{"categories":["反思"],"content":"思虑过载 变被动为主动，自己去决定「我要做什么」，重新找回「自主性」。 ","date":"2015-01-01","objectID":"/energy/:1:0","tags":["生活"],"title":"减缓焦虑，积聚生活正能量","uri":"/energy/"},{"categories":["反思"],"content":"前一天晚上做好安排 整理一遍任务清单，从收集/待办的池子中， 挑出5-6个最重要、最关键的任务，安排到第二天 ","date":"2015-01-01","objectID":"/energy/:1:1","tags":["生活"],"title":"减缓焦虑，积聚生活正能量","uri":"/energy/"},{"categories":["反思"],"content":"留出一定的宽裕度 做出取舍。该舍弃的，就果断舍弃。 与其把所有事情做到60分，不如把最重要的事情做到100分。 ","date":"2015-01-01","objectID":"/energy/:1:2","tags":["生活"],"title":"减缓焦虑，积聚生活正能量","uri":"/energy/"},{"categories":["反思"],"content":"聚焦在长期价值上 不妨这样问问自己：我可以做些什么，来摆脱目前这种忙碌的状态？ 无论是设计一套流程，还是把部分工作委托出去，又或者是把细碎的任务合并起来，还是优化、压缩任务步骤和时间……这些，长期来看都是更具价值的，也是你应该着重去聚焦的。 把它们作为你每天「最重要的事项」，想办法让自己能够抽身出来。 ","date":"2015-01-01","objectID":"/energy/:1:3","tags":["生活"],"title":"减缓焦虑，积聚生活正能量","uri":"/energy/"},{"categories":["反思"],"content":"被压榨感 什么是被压榨感？它是指：自己一直在劳动和付出，但却始终得不到反馈、认可和肯定，仿佛自己的付出都是无价值的。 去发现生活中微小的幸福感。 ","date":"2015-01-01","objectID":"/energy/:2:0","tags":["生活"],"title":"减缓焦虑，积聚生活正能量","uri":"/energy/"},{"categories":["反思"],"content":"决策疲劳 不要在晚上作出重要的决定。 通过给自己设立规则，让规则帮助自己作出决策。规则覆盖不到的地方，则用随机来解决。 ","date":"2015-01-01","objectID":"/energy/:3:0","tags":["生活"],"title":"减缓焦虑，积聚生活正能量","uri":"/energy/"},{"categories":["反思"],"content":"外在打扰 建立你的「第二大脑」，把思维外部化。 ","date":"2015-01-01","objectID":"/energy/:4:0","tags":["生活"],"title":"减缓焦虑，积聚生活正能量","uri":"/energy/"},{"categories":["反思"],"content":"信息过载 我们不断去追逐新信息，不断获取新鲜感的刺激，这本身是一个高耗能的行为 —— 但我们的大脑，会受到新鲜感的蛊惑，从而忽略和掩盖住这种耗能。 意识地克制自己，去做好信息的「反刍」，而非追逐新的信息。 试着把你记录的不同笔记放到一起，看看它们之间能产生什么联系，能否创造出新的火花。 在闲暇的碎片时间里，去反刍、回想自己记下的旧内容，尽量控制对新信息的摄入。 ","date":"2015-01-01","objectID":"/energy/:5:0","tags":["生活"],"title":"减缓焦虑，积聚生活正能量","uri":"/energy/"},{"categories":["反思"],"content":"tips 一定要睡好。 睡眠过程中的深度睡眠，能够有效促进腺苷到ATP的水合反应，为我们的机体储存能量、清除代谢垃圾。 请保证每天6小时以上不受干扰的睡眠，这极其重要。 多散步。 散步是最轻松有效的锻炼。不但能够促进血清素的合成，也能有效扩充大脑容量。波士顿大学的一项研究表明，每天步行1小时（约5000步），相当于大脑延缓衰老1年。 适当的运动。 每周 150 分钟一定强度的运动，能够有效提高心肺功能，从而提高每一天精力的上限。 这才是精力管理的关键 —— 上限太低，再怎么「管理」，也是无效的。 ","date":"2015-01-01","objectID":"/energy/:6:0","tags":["生活"],"title":"减缓焦虑，积聚生活正能量","uri":"/energy/"},{"categories":null,"content":"默哥","date":"2020-01-01","objectID":"/about/","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"用写作触发思考。 ","date":"2020-01-01","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"记录点滴，反哺归真","date":"0001-01-01","objectID":"/archives/","tags":null,"title":"归档","uri":"/archives/"},{"categories":null,"content":"搜索页面","date":"0001-01-01","objectID":"/search/","tags":null,"title":"搜索","uri":"/search/"}]