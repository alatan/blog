[{"categories":["数据结构"],"content":"数组是用于储存多个相同类型数据的集合","date":"2017-02-01","objectID":"/array/","tags":["数据结构"],"title":"数组","uri":"/array/"},{"categories":["数据结构"],"content":"定义 有限个相同数据类型的元素按顺序排列的集合为数组。 ","date":"2017-02-01","objectID":"/array/:1:0","tags":["数据结构"],"title":"数组","uri":"/array/"},{"categories":["数据结构"],"content":"特性 数组是相同数据类型的元素的集合。 数组中的各元素的存储是有先后顺序的，它们在内存中按照这个先后顺序连续存放在一起。 ","date":"2017-02-01","objectID":"/array/:2:0","tags":["数据结构"],"title":"数组","uri":"/array/"},{"categories":["数据结构"],"content":"优点： 由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间，查询修改元素的效率O(1)。 ","date":"2017-02-01","objectID":"/array/:3:0","tags":["数据结构"],"title":"数组","uri":"/array/"},{"categories":["数据结构"],"content":"缺点： 正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)。 想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N) ","date":"2017-02-01","objectID":"/array/:4:0","tags":["数据结构"],"title":"数组","uri":"/array/"},{"categories":["数据结构"],"content":"二维数组 二维数组也称为矩阵，因为是二维的，所以需要两个下标才能确定一个元素，即行下标和列下标。 ","date":"2017-02-01","objectID":"/array/:5:0","tags":["数据结构"],"title":"数组","uri":"/array/"},{"categories":["微服务"],"content":"微服务最佳实践方案","date":"2020-03-15","objectID":"/springcloudalibaba/","tags":["SpringCloud"],"title":"微服务方案SpringCloudAlibaba","uri":"/springcloudalibaba/"},{"categories":["微服务"],"content":"Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案 ","date":"2020-03-15","objectID":"/springcloudalibaba/:0:0","tags":["SpringCloud"],"title":"微服务方案SpringCloudAlibaba","uri":"/springcloudalibaba/"},{"categories":["微服务"],"content":"组件 Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。 Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。 ","date":"2020-03-15","objectID":"/springcloudalibaba/:0:1","tags":["SpringCloud"],"title":"微服务方案SpringCloudAlibaba","uri":"/springcloudalibaba/"},{"categories":["微服务"],"content":"微服务最佳实践 Spring Cloud - Gateway API网关 Spring Cloud - Ribbon 实现负载均衡 Spring Cloud - Feign 实现远程调用 Spring Cloud - Sleuth 实现调用链监控 Spring Cloud Alibaba - Nacos 实现注册中心 Spring Cloud Alibaba - Nacos 实现配置中心 Spring Cloud Alibaba - Sentinel 实现服务容错 Spring Cloud Alibaba - Seata 实现分布式事务 ","date":"2020-03-15","objectID":"/springcloudalibaba/:0:2","tags":["SpringCloud"],"title":"微服务方案SpringCloudAlibaba","uri":"/springcloudalibaba/"},{"categories":["分布式"],"content":"分布式基础介绍","date":"2020-03-10","objectID":"/distributed/","tags":["分布式"],"title":"分布式介绍","uri":"/distributed/"},{"categories":["分布式"],"content":"分布式理论基础 CAP 理论是分布式中基础理论，有三个重要指标：一致性、可用性、分区容错性。 一致性（Consistency） 可用性（Availability） 分区容错性（Partition Tolerance） ","date":"2020-03-10","objectID":"/distributed/:0:1","tags":["分布式"],"title":"分布式介绍","uri":"/distributed/"},{"categories":["知识体系"],"content":"Java架构演变历史","date":"2020-03-01","objectID":"/javaarchhistory/","tags":["大纲"],"title":"Java架构演变历史","uri":"/javaarchhistory/"},{"categories":["知识体系"],"content":"Java网站架构演变过程，大致分为5个阶段，分别为单体架构、集群架构、分布式架构、SOA架构和微服务架构。 ","date":"2020-03-01","objectID":"/javaarchhistory/:0:0","tags":["大纲"],"title":"Java架构演变历史","uri":"/javaarchhistory/"},{"categories":["知识体系"],"content":"单体架构 应用、数据库、文件都部署在一台机器上。简单来讲其实就是我们熟知的SSM架构(Spring+SpringMVC+MyBatis)，把所有的业务模块都放在一个应用中开发，这里面又衍生出三层架构，即表示层、业务逻辑层和数据库访问层，虽然在软件设计中划分了经典的三层模型，但是对业务场景没有划分，一个典型的单体应用就是将所有的业务场景的表示层、业务逻辑层和数据访问层放在一个工程项目中，最终经过编译、打包，部署在一台服务器上。 单体架构优点 部署简单: 由于是完整的结构体，可以直接部署在一个服务器上即可。 技术单一: 项目不需要复杂的技术栈，往往一套熟悉的技术栈就可以完成开发。 用人成本低: 单个程序员可以完成业务接口到数据库的整个流程。 单体架构缺点 系统启动慢： 一个进程包含了所有的业务逻辑，涉及到的启动模块过多，导致系统的启动、重启时间周期过长; 系统错误隔离性差、可用性差：任何一个模块的错误均可能造成整个系统的宕机; 可伸缩性差：系统的扩容只能只对这个应用进行扩容，不能做到对某个功能点进行扩容; 线上问题修复周期长：任何一个线上问题修复需要对整个应用系统进行全面升级。 ","date":"2020-03-01","objectID":"/javaarchhistory/:0:1","tags":["大纲"],"title":"Java架构演变历史","uri":"/javaarchhistory/"},{"categories":["知识体系"],"content":"集群架构 不同服务器部署同一套应用程序对外提供服务，实现服务的负载均衡或者互备(热备，主从)。同一种组件的多个实例，形成逻辑上的整体。单个节点可以提供完整服务，集群是物理形态。 集群架构相关技术点 应用和数据分离(大量用户高并发的访问导致系统性能越来越差，数据存储空间开始出现不足) 缓存的使用(QPS持续提高，为了降低接口访问时间、提高服务性能和并发，根据二八定律可以将80%的数据缓存) 负载均衡器的代理服务器 数据库读写分离 反向代理和CDN加速 ","date":"2020-03-01","objectID":"/javaarchhistory/:0:2","tags":["大纲"],"title":"Java架构演变历史","uri":"/javaarchhistory/"},{"categories":["知识体系"],"content":"分布式架构 服务的不同模块部署在不同的机器上，单个节点不能提供完整服务，需要多节点协调提供服务(相同组件部署在不同节点，节点间通过交互信息协作提供服务)，分布式强调的是工作方式。 分布式相关技术点 业务分库分表 NoSQL和搜索引擎对可伸缩的分布式特性具有更好的支持，应用服务器通过一个统一的数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。 业务模块拆分成子项目 ","date":"2020-03-01","objectID":"/javaarchhistory/:0:3","tags":["大纲"],"title":"Java架构演变历史","uri":"/javaarchhistory/"},{"categories":["知识体系"],"content":"SOA架构 面向服务的设计架构，其中包含多个服务，服务之间通过相互依赖最终提供一系列的功能。一个服务通常以独立的形式存在于操作系统进程中。各个服务之间通过网络调用。 中心化实现：ESB(企业服务总线)，各服务通过ESB进行交互，解决异构系统之间的连通性，通过协议转换，消息解析，消息路由把服务提供者的数据传送到服务消费者。 去中心化实现：微服务 ","date":"2020-03-01","objectID":"/javaarchhistory/:0:4","tags":["大纲"],"title":"Java架构演变历史","uri":"/javaarchhistory/"},{"categories":["知识体系"],"content":"微服务架构 在SOA上做的升华，微服务架构强调业务需要彻底组件化和服务化，原有的单个业务系统会拆分为多个可独立开发，设计，运行的小应用。这些小应用通过服务完成交互和集成。 ","date":"2020-03-01","objectID":"/javaarchhistory/:0:5","tags":["大纲"],"title":"Java架构演变历史","uri":"/javaarchhistory/"},{"categories":["知识体系"],"content":"Java知识大纲","date":"2020-01-01","objectID":"/javaoutline/","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"基础 数据结构与算法 操作系统 网络基础 数据库基础 编译原理 ","date":"2020-01-01","objectID":"/javaoutline/:1:0","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"Java Java基础 并发编程 JVM 性能优化 性能指标体系 JVM调优 Tomcat调优 MySQL调优 故障排除 ","date":"2020-01-01","objectID":"/javaoutline/:2:0","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"最佳实践 重构 设计模式 开发框架 Spring体系 MyBatis 常见业务 支付幂等性 减库存 秒杀 分布式锁 redis实现的分布式锁。 应该保证互斥性（在任何时候只有一个客户端持有锁。使用setnx）。 不能死锁（设置过期时间）。 保证上锁和解锁是同一个客户端（设置不同的value值）。 业务时间太长。导致锁过期（设置看门狗。自动续锁）。 锁的重入性（使用redis的hset）。 分布式事务 分布式缓存 ","date":"2020-01-01","objectID":"/javaoutline/:3:0","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"中间价 消息队列 缓存 本地缓存 分布式缓存 ELK 数据库 分库分表 数据同步 数据库连接池 ","date":"2020-01-01","objectID":"/javaoutline/:4:0","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"分布式 分布式架构原理 分布式架构策略 分布式中间件 分布式架构实战 四大理论 拜占庭将军问题 CAP 理论 ACID 理论 BASE 理论 八大协议/算法 Paxos 算法 Raft 算法 一致性 Hash 算法 Gossip 协议算法 Quorum NWR 算法 FBFT 算法 POW 算法 ZAB 协议 ","date":"2020-01-01","objectID":"/javaoutline/:5:0","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"微服务 ","date":"2020-01-01","objectID":"/javaoutline/:6:0","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["知识体系"],"content":"工具 版本管理 Git 项目管理 Maven/Gradle 代码质量管理 Sonar 持续集成部署 Jenkins\u0026GitLab CI/CD 监控系统 测试 Postman Jmeter VisualVM ","date":"2020-01-01","objectID":"/javaoutline/:7:0","tags":["大纲"],"title":"Java知识大纲","uri":"/javaoutline/"},{"categories":["Java基础"],"content":"ConcurrentHashMap详解","date":"2018-04-10","objectID":"/concurrenthashmap/","tags":["数据结构"],"title":"ConcurrentHashMap详解","uri":"/concurrenthashmap/"},{"categories":["Java基础"],"content":"synchronized详解","date":"2018-04-02","objectID":"/synchronized/","tags":["并发编程"],"title":"synchronized详解","uri":"/synchronized/"},{"categories":["Java基础"],"content":"synchronized的使用 对象锁 包括方法锁(默认锁对象为this,当前实例对象)和同步代码块锁(自己指定锁对象) 类锁 指synchronize修饰静态的方法或指定锁对象为Class对象 注意点 一把锁只能同时被一个线程获取，没有获得锁的线程只能等待。 每个实例都对应有自己的一把锁(this),不同实例之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用同一把锁 。 synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁。 ","date":"2018-04-02","objectID":"/synchronized/:1:0","tags":["并发编程"],"title":"synchronized详解","uri":"/synchronized/"},{"categories":["Java基础"],"content":"synchronized原理分析 加锁和释放锁的原理 Monitorenter和Monitorexit指令，会让对象在执行，使其锁计数器加1或者减1。每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的Monitor锁的所有权的时候，monitorenter指令会发生如下3中情况之一： monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待 如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加 这把锁已经被别的线程获取了，等待锁释放 monitorexit指令：释放对于monitor的所有权，释放过程很简单，就是讲monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁。 可重入原理：加锁次数计数器 上面的demo中在执行完同步代码块之后紧接着再会去执行一个静态同步方法，而这个方法锁的对象依然就这个类对象，那么这个正在执行的线程还需要获取该锁吗? 答案是不必的，从上图中就可以看出来，执行静态同步方法的时候就只有一条monitorexit指令，并没有monitorenter获取锁的指令。这就是锁的重入性，即在同一锁程中，线程不需要再次获取同一把锁。 synchronized先天具有重入性。每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一。 保证可见性的原理：内存模型和happens-before规则 Synchronized的happens-before规则，即监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁。继续来看代码： public class MonitorDemo { private int a = 0; public synchronized void writer() { // 1 a++; // 2 } // 3 public synchronized void reader() { // 4 int i = a; // 5 } // 6 } 该代码的happens-before关系如图所示： 在图中每一个箭头连接的两个节点就代表之间的happens-before关系，黑色的是通过程序顺序规则推导出来，红色的为监视器锁规则推导而出：线程A释放锁happens-before线程B加锁，蓝色的则是通过程序顺序规则和监视器锁规则推测出来happens-befor关系，通过传递性规则进一步推导的happens-before关系。现在我们来重点关注2 happens-before 5，通过这个关系我们可以得出什么? 根据happens-before的定义中的一条:如果A happens-before B，则A的执行结果对B可见，并且A的执行顺序先于B。线程A先对共享变量A进行加一，由2 happens-before 5关系可知线程A的执行结果对线程B可见即线程B所读取到的a的值为1。 ","date":"2018-04-02","objectID":"/synchronized/:2:0","tags":["并发编程"],"title":"synchronized详解","uri":"/synchronized/"},{"categories":["Java基础"],"content":"JVM中锁的优化 简单来说在JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的；然而在现实中的大部分情况下，同步方法是运行在单线程环境(无锁竞争环境)如果每次都调用Mutex Lock那么将严重的影响程序的性能。不过在jdk1.6中对锁的实现引入了大量的优化，如锁粗化(Lock Coarsening)、锁消除(Lock Elimination)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销。 锁粗化(Lock Coarsening)：也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。 锁消除(Lock Elimination)：通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本地Stack上进行对象空间的分配(同时还可以减少Heap上的垃圾收集开销)。 轻量级锁(Lightweight Locking)：这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态(即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒(具体处理步骤下面详细讨论)。 偏向锁(Biased Locking)：是为了在无锁竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟。 自适应自旋锁(Adaptive Spinning)：当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁(mutex semaphore)前会进入忙等待(Spinning)然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该monitor关联的semaphore(即互斥锁)进入到阻塞状态。 锁的类型 在Java SE 1.6里Synchronied同步锁，一共有四种状态：无锁、偏向锁、轻量级所、重量级锁，它会随着竞争情况逐渐升级。锁可以升级但是不可以降级，目的是为了提供获取锁和释放锁的效率。 锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的) 自旋锁与自适应自旋锁 自旋锁 引入背景：大家都知道，在没有加入锁优化时，Synchronized是一个非常“胖大”的家伙。在多线程竞争锁时，当一个线程获取锁时，它会阻塞所有正在竞争的线程，这样对性能带来了极大的影响。在挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作对系统的并发性能带来了很大的压力。同时HotSpot团队注意到在很多情况下，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和回复阻塞线程并不值得。在如今多处理器环境下，完全可以让另一个没有获取到锁的线程在门外等待一会(自旋)，但不放弃CPU的执行时间。等待持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需要让线程执行一个忙循环(自旋)，这便是自旋锁由来的原因。 自旋锁早在JDK1.4 中就引入了，只是当时默认时关闭的。在JDK 1.6后默认为开启状态。自旋锁本质上与阻塞并不相同，先不考虑其对多处理器的要求，如果锁占用的时间非常的短，那么自旋锁的新能会非常的好，相反，其会带来更多的性能开销(因为在线程自旋时，始终会占用CPU的时间片，如果锁占用的时间太长，那么自旋的线程会白白消耗掉CPU资源)。因此自旋等待的时间必须要有一定的限度，如果自选超过了限定的次数仍然没有成功获取到锁，就应该使用传统的方式去挂起线程了，在JDK定义中，自旋锁默认的自旋次数为10次，用户可以使用参数-XX:PreBlockSpin来更改。 可是现在又出现了一个问题：如果线程锁在线程自旋刚结束就释放掉了锁，那么是不是有点得不偿失。所以这时候我们需要更加聪明的锁来实现更加灵活的自旋。来提高并发的性能。(这里则需要自适应自旋锁！) 自适应自旋锁 在JDK 1.6中引入了自适应自旋锁。这就意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋 时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到100此循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，JVM对程序的锁的状态预测会越来越准备，JVM也会越来越聪明。 锁消除 锁消除时指虚拟机即时编译器再运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。意思就是：JVM会判断再一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那JVM就把它们当作栈上数据对待，认为这些数据时线程独有的，不需要加同步。此时就会进行锁消除。 ​ 当然在实际开发中，我们很清楚的知道那些地方时线程独有的，不需要加同步锁，但是在Java API中有很多方法都是加了同步的，那么此时JVM会判断这段代码是否需要加锁。如果数据并不会逃逸，则会进行锁消除。比如如下操作：在操作String类型数据时，由于String是一个不可变类，对字符串的连接操作总是通过生成的新的String对象来进行的。因此Javac编译器会对String连接做自动优化。在JDK 1.5之前会使用StringBuffer对象的连续append()操作，在JDK 1.5及以后的版本中，会转化为StringBuidler对象的连续append()操作。 public static String test03(String s1, String s2, String s3) { String s = s1 + s2 + s3; return s; } 上述代码使用javap 编译结果 众所周知，StringBuilder不是安全同步的，但是在上述代码中，JVM判断该段代码并不会逃逸，则将该代码带默认为线程独有的资源，并不需要同步，所以执行了锁消除操作。(还有Vector中的各种操作也可实现锁消除。在没有逃逸出数据安全防卫内) 锁粗化 ​原则上，我们都知道在加同步锁时，尽可能的将同步块的作用范围限制到尽量小的范围(只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。在存在锁同步竞争中，也可以使得等待锁的线程尽早的拿到锁)。 ​大部分上述情况是完美正确的，但是如果存在连串的一系列操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要地性能操作。 轻量级锁 ​在JDK 1.6之后引入的轻量级锁，需要注意的是轻量级锁并不是替代重量级锁的，而是对在大多数情况下同步块并不会有竞争出现提出的一种优化。它可以减少重量级锁对线程的阻塞带来地线程开销。从而提高并发性能。 ​如果要理解轻量级锁，那么必须先要了解HotSpot虚拟机中对象头地内存布局。上面介绍Java对象头也详细介绍过。在对象头中(Object Header)存在两部分。第一部分用于存储对象自身的运行时数据，HashCode、GC Age、锁标记位、是否为偏向锁。等。一般为32位或者64位(视操作系统位数定)。官方称之为Mark Word，它是实现轻量级锁和偏向锁的关键。 另外一部分存储的是指向方法区对象类型数据的指针(Klass Point)，如果对象是数组的话，还会有一个额外的部分用于存储数据的长度。 轻量级锁加锁 在线程执行同步块之前，JVM会先在当前线程的栈帧中创建一个名为锁记录(Lock Record)的空间，用于存储锁对象目前的Mark Word的拷贝(JVM会将对象头中的Mark Word拷贝到锁记录中，官方称为Displaced Mark Ward)这个时候线程堆栈与对象头的状态如图： 如上图所示：如果当前对象没有被锁定，那么锁标志位位01状态，JVM在执行当前线程时，首先会在当前线程栈帧中创建锁记录Lock Record的空间用于存储锁对象目前的Mark Word的拷贝。 ​ 然后，虚拟机使用CAS操作将标记字段Mark Word拷贝到锁记录中，并且将Mark Word更新为指向Lock Record的指针。如果更新成功了，那么这个线程就有用了该对象的锁，并且对象Mark Word的锁标志位更新为(Mark Word中最后的2bit)00，即表示此对象处于轻量级锁定状态，如图： 如果这个更新操作失败，JVM会检查当前的Mark Word中是否存在指向当前线程的栈帧的指针，如果有，说明该锁已经被获取，可以直接调用。如果没有，则说明该锁被其他线程抢占了，如果有两条以上的线程竞争同一个锁，那轻量级锁就不再有效，直接膨胀位重量级锁，没有获得锁的线程会被阻塞。此时，锁的标志位为10.Mark Word中存储的时指向重量级锁的指针。 ​ 轻量级解锁时，会使用原","date":"2018-04-02","objectID":"/synchronized/:3:0","tags":["并发编程"],"title":"synchronized详解","uri":"/synchronized/"},{"categories":["Java基础"],"content":"synchronized与Lock synchronized的缺陷 效率低：锁的释放情况少，只有代码执行完毕或者异常结束才会释放锁；试图获取锁的时候不能设定超时，不能中断一个正在使用锁的线程，相对而言，Lock可以中断和设置超时 不够灵活：加锁和释放的时机单一，每个锁仅有一个单一的条件(某个对象)，相对而言，读写锁更加灵活 无法知道是否成功获得锁，相对而言，Lock可以拿到状态，如果成功获取锁，....，如果获取失败，..... Lock解决相应问题 Lock类这里不做过多解释，主要看里面的4个方法: lock(): 加锁 unlock(): 解锁 tryLock(): 尝试获取锁，返回一个boolean值 tryLock(long,TimeUtil): 尝试获取锁，可以设置超时 Synchronized只有锁只与一个条件(是否获取锁)相关联，不灵活，后来Condition与Lock的结合解决了这个问题。 多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断。高并发的情况下会导致性能下降。ReentrantLock的lockInterruptibly()方法可以优先考虑响应中断。 一个线程等待时间过长，它可以中断自己，然后ReentrantLock响应这个中断，不再让这个线程继续等待。有了这个机制，使用ReentrantLock时就不会像synchronized那样产生死锁了。 ","date":"2018-04-02","objectID":"/synchronized/:4:0","tags":["并发编程"],"title":"synchronized详解","uri":"/synchronized/"},{"categories":["Java基础"],"content":"再深入理解 synchronized是通过软件(JVM)实现的，简单易用，即使在JDK5之后有了Lock，仍然被广泛地使用。 使用synchronized有哪些要注意的？ 锁对象不能为空，因为锁的信息都保存在对象头里 作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错 避免死锁 在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错 synchronized是公平锁吗？ synchronized实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待，不过这种抢占的方式可以预防饥饿。 ","date":"2018-04-02","objectID":"/synchronized/:5:0","tags":["并发编程"],"title":"synchronized详解","uri":"/synchronized/"},{"categories":["Java基础"],"content":"参考文章 synchronized详解 ","date":"2018-04-02","objectID":"/synchronized/:6:0","tags":["并发编程"],"title":"synchronized详解","uri":"/synchronized/"},{"categories":["Java基础"],"content":"Java并发编程","date":"2018-04-01","objectID":"/javacurrent/","tags":["并发编程"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"并发三要素 可见性 一个线程对共享变量的修改，另外一个线程能够立刻看到；产生原因：CPU增加了缓存，以均衡与内存的速度差异导致。 原子性 一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行；产生原因：操作系统增加了进程、线程，以分时复用CPU，进而均衡CPU与I/O设备的速度差异导致。 x = 10; //语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中 y = x; //语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。 x++; //语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。 x = x + 1; //语句4： 同语句3 有序性 程序执行的顺序按照代码的先后顺序执行；产生原因：由于编译程序指令重排序优化指令执行次序，使得缓存能够得到更加合理地利用导致。 ","date":"2018-04-01","objectID":"/javacurrent/:1:0","tags":["并发编程"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"线程安全的实现方法 互斥同步(阻塞同步) synchronized(JVM实现) ReentrantLock(JDK实现) 互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。 互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。 非阻塞同步 CAS 随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。 乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。 硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，CAS)。 CAS指令需要有3个操作数，分别是内存地址V旧的预期值A和新值B。当执行操作时，只有当V的值等于A，才将V的值更新为B。 无需同步方案 栈封闭（多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。） 线程本地存储(可以使用java.lang.ThreadLocal类来实现线程本地存储功能) 如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。 符合这种特点的应用并不少见，大部分使用消费队列的架构模式(如“生产者-消费者”模式)都会将产品的消费过程尽量在一个线程中消费完。 其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”(Thread-per-Request)的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。 ","date":"2018-04-01","objectID":"/javacurrent/:2:0","tags":["并发编程"],"title":"Java并发编程概览","uri":"/javacurrent/"},{"categories":["Java基础"],"content":"HashMap详解","date":"2018-03-03","objectID":"/hashmap/","tags":["数据结构"],"title":"HashMap详解","uri":"/hashmap/"},{"categories":["Java基础"],"content":"实现步骤 HashMap基于哈希散列表，数组+链表/红黑树实现。 通过key的hashCode()方法计算出hashCode。 通过HashMap类中内部hash()方法将第2步中hashCode带入得出hash值。 通过第3步中hash值和HashMap中数组长度做\u0026(位运算)得出在数组中的位置。 当第4步中位置中没有值则直接放入。 当第4步中位置中有值即产生hash冲突问题，此时通过链表(拉链法)来解决hash冲突问题。 如果第6步中第链表大小超过阈值（TREEIFY_THRESHOLD,8），链表转换为红黑树。 在转换为红黑树时，会判断数组长度大于64才转换，否则继续采用扩容策略而不转换。 ","date":"2018-03-03","objectID":"/hashmap/:1:0","tags":["数据结构"],"title":"HashMap详解","uri":"/hashmap/"},{"categories":["Java基础"],"content":"关键特性 默认初始容量值为16，负载因子为0.75，当size\u003e=threshold（ threshold等于“容量负载因子”）时，会发生扩容：newsize = oldsize2，size一定为2的n次幂 hash冲突默认采用单链表存储，当单链表节点个数大于8时且数组长度大于64，会转化为红黑树存储， 当红黑树中节点少于6时，则转化为单链表存储。 扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入 当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀 ","date":"2018-03-03","objectID":"/hashmap/:2:0","tags":["数据结构"],"title":"HashMap详解","uri":"/hashmap/"},{"categories":["Java基础"],"content":"HashMap在1.7和1.8之间的变化： 1.7中是先扩容后插入新值的，1.8中是先插值再扩容 1.7中采用数组+链表，1.8采用的是数组+链表/红黑树，即在1.7中链表长度超过一定长度后就改成红黑树存储。 1.7扩容时需要重新计算哈希值和索引位置，1.8并不重新计算哈希值，巧妙地采用和扩容后容量进行\u0026操作来计算新的索引位置。 1.7是采用表头插入法插入链表，1.8采用的是尾部插入法。 在1.7中采用表头插入法，在扩容时会改变链表中元素原本的顺序，以至于在并发场景下导致链表成环的问题；在1.8中采用尾部插入法，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。 ","date":"2018-03-03","objectID":"/hashmap/:3:0","tags":["数据结构"],"title":"HashMap详解","uri":"/hashmap/"},{"categories":["Java基础"],"content":"方法（JDK1.8-数组+链表/红黑树） 确定哈希桶数组索引位置 第1步计算hash 在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h \u003e\u003e\u003e 16)，主要是从速度、功效、质量来考虑的。 目的都是在数组很小也能降低hash碰撞。 static final int hash(Object key) { int h; // key.hashCode()：返回散列值也就是hashcode // ^ ：按位异或 // \u003e\u003e\u003e:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u003e\u003e\u003e 16); } 第2步计算数组位置 通过(n - 1) \u0026 hash来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方。 当length总是2的n次方时，h\u0026 (length-1)运算等价于对length取模，也就是h%length，但是\u0026(位运算)比%(取模运算)具有更高的效率。 (n - 1) \u0026 hash HashMap的put方法 public V put(K key, V value) { // 对key的hashCode()做hash return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e p; int n, i; // 步骤①：tab为空则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 步骤②：计算index，并对null做处理 if ((p = tab[i = (n - 1) \u0026 hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node\u003cK,V\u003e e; K k; // 步骤③：节点key存在，直接覆盖value if (p.hash == hash \u0026\u0026 ((k = p.key) == key || (key != null \u0026\u0026 key.equals(k)))) e = p; // 步骤④：判断该链为红黑树 else if (p instanceof TreeNode) e = ((TreeNode\u003cK,V\u003e)p).putTreeVal(this, tab, hash, key, value); // 步骤⑤：该链为链表 else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key,value,null); //链表长度大于8转换为红黑树进行处理 if (binCount \u003e= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } // key已经存在直接覆盖value if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; // 步骤⑥：超过最大容量 就扩容 if (++size \u003e threshold) resize(); afterNodeInsertion(evict); return null; } final void treeifyBin(Node\u003cK,V\u003e[] tab, int hash) { int n, index; Node\u003cK,V\u003e e; //树形化还有一个要求就是数组长度必须大于等于64，否则继续采用扩容策略 if (tab == null || (n = tab.length) \u003c MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) \u0026 hash]) != null) { TreeNode\u003cK,V\u003e hd = null, tl = null;//hd指向首节点，tl指向尾节点 do { TreeNode\u003cK,V\u003e p = replacementTreeNode(e, null);//将链表节点转化为红黑树节点 if (tl == null) // 如果尾节点为空，说明还没有首节点 hd = p; // 当前节点作为首节点 else { // 尾节点不为空，构造一个双向链表结构，将当前节点追加到双向链表的末尾 p.prev = tl; // 当前树节点的前一个节点指向尾节点 tl.next = p; // 尾节点的后一个节点指向当前节点 } tl = p; // 把当前节点设为尾节点 } while ((e = e.next) != null); // 继续遍历单链表 //将原本的单链表转化为一个节点类型为TreeNode的双向链表 if ((tab[index] = hd) != null) // 把转换后的双向链表，替换数组原来位置上的单向链表 hd.treeify(tab); // 将当前双向链表树形化 } } //将双向链表转化为红黑树的实现 final void treeify(Node\u003cK,V\u003e[] tab) { TreeNode\u003cK,V\u003e root = null; // 定义红黑树的根节点 for (TreeNode\u003cK,V\u003e x = this, next; x != null; x = next) { // 从TreeNode双向链表的头节点开始逐个遍历 next = (TreeNode\u003cK,V\u003e)x.next; // 头节点的后继节点 x.left = x.right = null; if (root == null) { x.parent = null; x.red = false; root = x; // 头节点作为红黑树的根，设置为黑色 } else { // 红黑树存在根节点 K k = x.key; int h = x.hash; Class\u003c?\u003e kc = null; for (TreeNode\u003cK,V\u003e p = root;;) { // 从根开始遍历整个红黑树 int dir, ph; K pk = p.key; if ((ph = p.hash) \u003e h) // 当前红黑树节点p的hash值大于双向链表节点x的哈希值 dir = -1; else if (ph \u003c h) // 当前红黑树节点的hash值小于双向链表节点x的哈希值 dir = 1; else if ((kc == null \u0026\u0026 (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) // 当前红黑树节点的hash值等于双向链表节点x的哈希值，则如果key值采用比较器一致则比较key值 dir = tieBreakOrder(k, pk); //如果key值也一致则比较className和identityHashCode TreeNode\u003cK,V\u003e xp = p; if ((p = (dir \u003c= 0) ? p.left : p.right) == null) { // 如果当前红黑树节点p是叶子节点，那么双向链表节点x就找到了插入的位置 x.parent = xp; if (dir \u003c= 0) //根据dir的值，插入到p的左孩子或者右孩子 xp.left = x; else xp.right = x; root = balanceInsertion(root, x); //红黑树中插入元素，需要进行平衡调整(过程和TreeMap调整逻辑一模一样) break; } } } } //将TreeNode双向链表转化为红黑树结构之后，由于红黑树是基于根节点进行查找，所以必须将红黑树的根节点作为数组当前位置的元素 moveRootToFront(tab, root); } //然后将红黑树的根节点移动端数组的索引所在位置上 static \u003cK,V\u003e void moveRootToFront(Node\u003cK,V\u003e[] tab, TreeNode\u003cK,V\u003e root) { int n; if (root != null \u0026\u0026 tab != null \u0026\u0026 (n = tab.length) \u003e 0) { int index = (n - 1) \u0026 root.hash; //找到红黑树根节点在数组中的位置 TreeNode\u003cK,V\u003e first = (TreeNode\u003cK,V\u003e)tab[ind","date":"2018-03-03","objectID":"/hashmap/:4:0","tags":["数据结构"],"title":"HashMap详解","uri":"/hashmap/"},{"categories":["Java基础"],"content":"参考文章 https://www.hollischuang.com/archives/2091 https://yuanrengu.com/2020/ba184259.html https://zhuanlan.zhihu.com/p/21673805 ","date":"2018-03-03","objectID":"/hashmap/:5:0","tags":["数据结构"],"title":"HashMap详解","uri":"/hashmap/"},{"categories":["Java基础"],"content":"ArrayList详解","date":"2018-03-02","objectID":"/arraylist/","tags":["数据结构"],"title":"ArrayList详解","uri":"/arraylist/"},{"categories":["Java基础"],"content":"ArrayList 简介 ArrayList 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用ensureCapacity操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。 ","date":"2018-03-02","objectID":"/arraylist/:1:0","tags":["数据结构"],"title":"ArrayList详解","uri":"/arraylist/"},{"categories":["Java基础"],"content":"ArrayList 核心源码解读 package java.util; import java.util.function.Consumer; import java.util.function.Predicate; import java.util.function.UnaryOperator; public class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e implements List\u003cE\u003e, RandomAccess, Cloneable, java.io.Serializable { private static final long serialVersionUID = 8683452581122892189L; /** * 默认初始容量大小 */ private static final int DEFAULT_CAPACITY = 10; /** * 空数组（用于空实例）。 */ private static final Object[] EMPTY_ELEMENTDATA = {}; //用于默认大小空实例的共享空数组实例。 //我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /** * 保存ArrayList数据的数组 */ transient Object[] elementData; // non-private to simplify nested class access /** * ArrayList 所包含的元素个数 */ private int size; /** * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小） */ public ArrayList(int initialCapacity) { if (initialCapacity \u003e 0) { //如果传入的参数大于0，创建initialCapacity大小的数组 this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { //如果传入的参数等于0，创建空数组 this.elementData = EMPTY_ELEMENTDATA; } else { //其他情况，抛出异常 throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); } } /** *默认无参构造函数 *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10 */ public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } /** * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。 */ public ArrayList(Collection\u003c? extends E\u003e c) { //将指定集合转换为数组 elementData = c.toArray(); //如果elementData数组的长度不为0 if ((size = elementData.length) != 0) { // 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断） if (elementData.getClass() != Object[].class) //将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组 elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // 其他情况，用空数组代替 this.elementData = EMPTY_ELEMENTDATA; } } /** * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。 */ public void trimToSize() { modCount++; if (size \u003c elementData.length) { elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); } } //下面是ArrayList的扩容机制 //ArrayList的扩容机制提高了性能，如果每次只扩充一个， //那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。 /** * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量 * @param minCapacity 所需的最小容量 */ public void ensureCapacity(int minCapacity) { //如果是true，minExpand的值为0，如果是false,minExpand的值为10 int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; //如果最小容量大于已有的最大容量 if (minCapacity \u003e minExpand) { ensureExplicitCapacity(minCapacity); } } //得到最小扩容量 private void ensureCapacityInternal(int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { // 获取“默认的容量”和“传入参数”两者之间的最大值 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); } ensureExplicitCapacity(minCapacity); } //判断是否需要扩容 private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length \u003e 0) //调用grow方法进行扩容，调用此方法代表已经开始扩容了 grow(minCapacity); } /** * 要分配的最大数组大小 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * ArrayList扩容的核心方法。 */ private void grow(int minCapacity) { // oldCapacity为旧容量，newCapacity为新容量 int oldCapacity = elementData.length; //将oldCapacity 右移一位，其效果相当于oldCapacity /2， //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍， int newCapacity = oldCapacity + (oldCapacity \u003e\u003e 1); //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量， if (newCapacity - minCapacity \u003c 0) newCapacity = minCapacity; //再检查新容量是否超出了ArrayList所定义的最大容量， //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE， //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。 if (newCapacity - MAX_ARRAY_SIZE \u003e 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } //比较minCapacity和 MAX_ARRAY_SIZE private static int hug","date":"2018-03-02","objectID":"/arraylist/:2:0","tags":["数据结构"],"title":"ArrayList详解","uri":"/arraylist/"},{"categories":["Java基础"],"content":"Java容器","date":"2018-03-01","objectID":"/javacontainer/","tags":["数据结构"],"title":"Java容器概览","uri":"/javacontainer/"},{"categories":["Java基础"],"content":"概览 容器主要包括Collection和Map 两种，Collection存储着对象的集合，而Map存储着键值对（两个对象）的映射表。 ","date":"2018-03-01","objectID":"/javacontainer/:1:0","tags":["数据结构"],"title":"Java容器概览","uri":"/javacontainer/"},{"categories":["Java基础"],"content":"Collection ","date":"2018-03-01","objectID":"/javacontainer/:2:0","tags":["数据结构"],"title":"Java容器概览","uri":"/javacontainer/"},{"categories":["Java基础"],"content":"List 对付顺序的好帮手： 存储的元素是有序的、可重复的。 ArrayList：基于动态数组实现，支持随机访问，适用于频繁的查找工作。 Vector：和ArrayList类似，但它是线程安全的。 LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList还可以用作栈、队列和双向队列。 Arraylist与 LinkedList 区别? 是否保证线程安全： ArrayList和LinkedList都是不同步的，也就是不保证线程安全； 底层数据结构： Arraylist底层使用的是Object数组；LinkedList底层使用的是双向链表数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。） 插入和删除是否受元素位置的影响： ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 LinkedList 采用链表存储，所以对于add(E e)方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置 i 插入和删除元素的话（(add(int index, E element)） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。 是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。 内存空间占用： ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。 ","date":"2018-03-01","objectID":"/javacontainer/:2:1","tags":["数据结构"],"title":"Java容器概览","uri":"/javacontainer/"},{"categories":["Java基础"],"content":"Set 注重独一无二的性质: 存储的元素是无序的、不可重复的。 HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。基于 HashMap 实现的，底层采用 HashMap 来保存元素。 LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。LinkedHashSet 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。 TreeSet：基于红黑树实现（(自平衡的排序二叉树)），支持有序性操作，例如根据一个范围查找元素的操作。查找效率不如HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 HashSet 如何检查重复 当你把对象加入HashSet时，HashSet 会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。 hashCode()与 equals() 的相关规定： 如果两个对象相等，则 hashcode 一定也是相同的 两个对象相等,对两个 equals() 方法返回 true 两个对象有相同的 hashcode 值，它们也不一定是相等的 综上，equals() 方法被覆盖过，则 hashCode() 方法也必须被覆盖 hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。 ","date":"2018-03-01","objectID":"/javacontainer/:2:2","tags":["数据结构"],"title":"Java容器概览","uri":"/javacontainer/"},{"categories":["Java基础"],"content":"Queue LinkedList：可以用它来实现双向队列。 PriorityQueue：基于堆结构实现，可以用它来实现优先队列。 ","date":"2018-03-01","objectID":"/javacontainer/:2:3","tags":["数据结构"],"title":"Java容器概览","uri":"/javacontainer/"},{"categories":["Java基础"],"content":"Map 用 Key 来搜索的专家: 使用键值对（key-value）存储，Key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。 TreeMap： 红黑树（自平衡的排序二叉树） HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高。 LinkedHashMap：LinkedHashMap 继承自 HashMap，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。 ","date":"2018-03-01","objectID":"/javacontainer/:3:0","tags":["数据结构"],"title":"Java容器概览","uri":"/javacontainer/"},{"categories":["Java基础"],"content":"如何选择 主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 Map 接口下的集合，需要排序时选择 TreeMap,不需要排序时就选择 HashMap,需要保证线程安全就选用 ConcurrentHashMap。 当我们只需要存放元素值时，就选择实现Collection 接口的集合，需要保证元素唯一时选择实现 Set 接口的集合比如 TreeSet 或 HashSet，不需要就选择实现 List 接口的比如 ArrayList 或 LinkedList，然后再根据实现这些接口的集合的特点来选用。 ","date":"2018-03-01","objectID":"/javacontainer/:4:0","tags":["数据结构"],"title":"Java容器概览","uri":"/javacontainer/"},{"categories":["Java基础"],"content":"为什么要使用 当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端，因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。 数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。 但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。 ","date":"2018-03-01","objectID":"/javacontainer/:5:0","tags":["数据结构"],"title":"Java容器概览","uri":"/javacontainer/"},{"categories":["Java基础"],"content":"反射让一切有了可能","date":"2018-02-03","objectID":"/reflection/","tags":["Java基础"],"title":"框架的灵魂-反射","uri":"/reflection/"},{"categories":["Java基础"],"content":"什么是反射 简而言之，通过反射，我们可以在运行时获得程序中每一个类型的成员和成员的信息。 程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。 所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。 反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。 ","date":"2018-02-03","objectID":"/reflection/:1:0","tags":["Java基础"],"title":"框架的灵魂-反射","uri":"/reflection/"},{"categories":["Java基础"],"content":"Java 反射主要提供以下功能 在运行时构造任意一个类的对象。 在运行时调用任意一个对象的方法。 在运行时判断任意一个对象所属的类。 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）。 ","date":"2018-02-03","objectID":"/reflection/:1:1","tags":["Java基础"],"title":"框架的灵魂-反射","uri":"/reflection/"},{"categories":["Java基础"],"content":"反射的主要用途 反射最重要的用途就是开发各种通用框架。 很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。 举一个例子，在运用 Struts 2 框架的开发中我们一般会在 struts.xml 里去配置 Action，比如： \u003caction name=\"login\" class=\"org.ScZyhSoft.test.action.SimpleLoginAction\" method=\"execute\"\u003e \u003cresult\u003e/shop/shop-index.jsp\u003c/result\u003e \u003cresult name=\"error\"\u003elogin.jsp\u003c/result\u003e \u003c/action\u003e 配置文件与 Action 建立了一种映射关系，当 View 层发出请求时，请求会被 StrutsPrepareAndExecuteFilter 拦截，然后 StrutsPrepareAndExecuteFilter 会去动态地创建 Action 实例。比如我们请求 login.action，那么 StrutsPrepareAndExecuteFilter就会去解析struts.xml文件，检索action中name为login的Action，并根据class属性创建SimpleLoginAction实例，并用invoke方法来调用execute方法，这个过程离不开反射。 对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。 像Java中的一大利器注解的实现也用到了反射。 为什么你使用 Spring 的时候 ，一个@Component注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 @Value注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？ 这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。 ","date":"2018-02-03","objectID":"/reflection/:2:0","tags":["Java基础"],"title":"框架的灵魂-反射","uri":"/reflection/"},{"categories":["Java基础"],"content":"反射的基本运用 ","date":"2018-02-03","objectID":"/reflection/:3:0","tags":["Java基础"],"title":"框架的灵魂-反射","uri":"/reflection/"},{"categories":["Java基础"],"content":"获得Class对象 使用Class类的forName 静态方法。 Class appleClass = Class.forName(\"base.reflection.Apple\"); 直接获取 Class appleClass = Apple.class; 获取某一个对象的class Apple apple = new Apple(); Class appleClass = apple.getClass(); 通过类加载器ClassLoader.loadClass()传入类路径获取 Class appleClass = ClassLoader.getSystemClassLoader().loadClass(\"base.reflection.Apple\"); ","date":"2018-02-03","objectID":"/reflection/:3:1","tags":["Java基础"],"title":"框架的灵魂-反射","uri":"/reflection/"},{"categories":["Java基础"],"content":"构造方法 Constructor[] declaredConstructors = appleClass.getDeclaredConstructors(); Constructor[] constructors = appleClass.getConstructors(); //通过无参构造来获取该类对象 newInstance() Apple apple= (Apple)appleClass.newInstance(); //通过有参构造来获取该类对象 newInstance Constructor constructor = appleClass.getConstructor(String.class,int.class,int.class); Apple apple=(Apple)constructor.newInstance(\"红色\",10,5); ","date":"2018-02-03","objectID":"/reflection/:3:2","tags":["Java基础"],"title":"框架的灵魂-反射","uri":"/reflection/"},{"categories":["Java基础"],"content":"属性 //getDeclaredFields所有已声明的成员变量，但不能得到其父类的成员变量 Field[] declaredFields = appleClass.getDeclaredFields(); //getFields访问公有的成员变量 Field[] fields = appleClass.getFields(); ","date":"2018-02-03","objectID":"/reflection/:3:3","tags":["Java基础"],"title":"框架的灵魂-反射","uri":"/reflection/"},{"categories":["Java基础"],"content":"方法 //getDeclaredMethods 方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 Method[] declaredMethods = appleClass.getDeclaredMethods(); //getMethods方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。 Method[] methods = appleClass.getMethods(); ","date":"2018-02-03","objectID":"/reflection/:3:4","tags":["Java基础"],"title":"框架的灵魂-反射","uri":"/reflection/"},{"categories":["Java基础"],"content":"调用方法 Constructor constructor = appleClass.getConstructor(String.class,int.class,int.class); Apple apple = (Apple)constructor.newInstance(\"红色\",10,5); //获取toString方法并调用 Method method = appleClass.getDeclaredMethod(\"toString\"); String str = (String)method.invoke(apple); System.out.println(str); ","date":"2018-02-03","objectID":"/reflection/:3:5","tags":["Java基础"],"title":"框架的灵魂-反射","uri":"/reflection/"},{"categories":["Java基础"],"content":"利用反射创建数组 Class\u003c?\u003e cls = Class.forName(\"java.lang.String\"); Object array = Array.newInstance(cls,5); //往数组里添加内容 Array.set(array,0,\"hello\"); Array.set(array,1,\"Java\"); Array.set(array,2,\"fuck\"); Array.set(array,3,\"Scala\"); Array.set(array,4,\"Clojure\"); //获取某一项的内容 System.out.println(Array.get(array,3)); ","date":"2018-02-03","objectID":"/reflection/:3:6","tags":["Java基础"],"title":"框架的灵魂-反射","uri":"/reflection/"},{"categories":["Java基础"],"content":"参数化类型","date":"2018-02-02","objectID":"/generic/","tags":["Java基础"],"title":"Java特性-泛型","uri":"/generic/"},{"categories":["Java基础"],"content":"泛型，即参数化类型。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。 那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（类型形参），然后在使用/调用时传入具体的类型（类型实参）。 Java 语言中引入泛型是一个较大的功能增强。不仅语言、类型系统和编译器有了较大的变化，而且类库也进行了大翻修，所以许多重要的类，比如集合框架，都已经成为泛型化的了。这带来了很多好处： 类型安全。 泛型的主要目标是提高 Java 程序的类型安全。通过知道使用泛型定义的变量的类型限制，编译器可以在一个高得多的程度上验证类型假设。 消除强制类型转换。 泛型的一个附带好处是，消除源代码中的许多强制类型转换。这使得代码更加可读，并且减少了出错机会。 潜在的性能收益。 泛型为较大的优化带来可能。在泛型的初始实现中，编译器将强制类型转换（没有泛型的话，程序员会指定这些强制类型转换）插入生成的字节码中。 注意泛型的类型参数只能是类类型（包括自定义类），不能是简单类型。 ","date":"2018-02-02","objectID":"/generic/:0:0","tags":["Java基础"],"title":"Java特性-泛型","uri":"/generic/"},{"categories":["Java基础"],"content":"常用命名类型参数 K：键，比如映射的键 V：值，比如 List 和 Set 的内容，或者 Map 中的值 E：元素 T：泛型 ?：表示不确定的 java 类型 ","date":"2018-02-02","objectID":"/generic/:0:1","tags":["Java基础"],"title":"Java特性-泛型","uri":"/generic/"},{"categories":["Java基础"],"content":"通配符 Ingeter 是 Number 的一个子类，同时 Generic 与 Generic 实际上是相同的一种基本类型。那么问题来了，在使用 Generic 作为形参的方法中，能否使用Generic 的实例传入呢？在逻辑上类似于 Generic 和 Generic 是否可以看成具有父子关系的泛型类型呢？下面我们通过定义一个方法来验证。 public void show(Generic\u003cNumber\u003e obj) { System.out.println(\"key value is \" + obj.getKey()); } 进行如下的调用： Generic\u003cInteger\u003e genericInteger = new Generic\u003cInteger\u003e(123); show(genericInteger); //error Generic\u003cjava.lang.Integer\u003e cannot be applied to Generic\u003cjava.lang.Number\u003e 通过提示信息我们可以看到 Generic 不能被看作为 Generic 的子类。由此可以看出：同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。 我们不能因此定义一个 show(Generic obj)来处理，因此我们需要一个在逻辑上可以表示同时是Generic和Generic父类的引用类型。由此类型通配符应运而生。 T、K、V、E 等泛型字母为有类型，类型参数赋予具体的值。除了有类型，还可以用通配符来表述类型，？ 未知类型，类型参数赋予不确定值，任意类型只能用在声明类型、方法参数上，不能用在定义泛型类上。将方法改写成如下： public void show(Generic\u003c?\u003e obj) { System.out.println(\"key value is \" + obj.getKey()); } 此处 ? 是类型实参，而不是类型形参。即和 Number、String、Integer 一样都是实际的类型，可以把 ？ 看成所有类型的父类，是一种真实的类型。可以解决当具体类型不确定的时候，这个通配符就是 ?；当操作类型时，不需要使用类型的具体功能时，只使用 Object 类中的功能。那么可以用 ? 通配符来表未知类型。 ","date":"2018-02-02","objectID":"/generic/:0:2","tags":["Java基础"],"title":"Java特性-泛型","uri":"/generic/"},{"categories":["Java基础"],"content":"泛型上下边界 通配符上限为：Generic\u003c? extends Number\u003e 通配符下限为：Generic\u003c? super Number\u003e 在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。为泛型添加上边界，即传入的类型实参必须是指定类型的子类型。 public void show(Generic\u003c? extends Number\u003e obj) { System.out.println(\"key value is \" + obj.getKey()); } 我们在泛型方法的入参限定参数类型为 Number 的子类。 Generic\u003cString\u003e genericString = new Generic\u003cString\u003e(\"11111\"); Generic\u003cInteger\u003e genericInteger = new Generic\u003cInteger\u003e(2222); showKeyValue1(genericString); // error showKeyValue1(genericInteger); 当我们的入参为 String 类型时，编译报错，因为 String 类型并不是 Number 类型的子类。 类型通配符上限通过形如 Generic\u003c? extends Number\u003e 形式定义；相对应的，类型通配符下限为Generic\u003c? super Number\u003e形式，其含义与类型通配符上限正好相反，在此不作过多阐述。 ","date":"2018-02-02","objectID":"/generic/:0:3","tags":["Java基础"],"title":"Java特性-泛型","uri":"/generic/"},{"categories":["Java基础"],"content":"一个泛型的增删改查Service @Transactional(readOnly = true) public abstract class CrudService\u003cD extends CrudDao\u003cT\u003e, T extends DataEntity\u003cT\u003e\u003e extends BaseService { /** * 持久层对象 */ @Autowired protected D dao; /** * 获取单条数据 * @param entity * @return */ public T get(T entity) { return dao.get(entity); } /** * 查询列表数据 * @param entity * @return */ public List\u003cT\u003e findList(T entity) { return dao.findList(entity); } /** * 查询分页数据 * @param page 分页对象 * @param entity * @return */ public Page\u003cT\u003e findPage(Page\u003cT\u003e page, T entity) { entity.setPage(page); page.setList(dao.findList(entity)); return page; } /** * 保存数据（插入或更新） * @param entity */ @Transactional(readOnly = false) public int save(T entity) { if (entity.getIsNewRecord()){ entity.preInsert(); return dao.insert(entity); }else{ entity.preUpdate(); return dao.update(entity); } } /** * 删除数据 * @param entity */ @Transactional(readOnly = false) public int delete(T entity) { return dao.delete(entity); } } ","date":"2018-02-02","objectID":"/generic/:0:4","tags":["Java基础"],"title":"Java特性-泛型","uri":"/generic/"},{"categories":["Java基础"],"content":"面向对象的三大法宝和七大戒律","date":"2018-02-01","objectID":"/object-oriented/","tags":["Java基础"],"title":"Java世界的入场券-面向对象","uri":"/object-oriented/"},{"categories":["Java基础"],"content":" 面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的编程典范，同时也是一种程序开发的抽象方针。它可能包含数据、特性、代码与方法。对象则指的是类（class）的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。 面向对象就像是一张入场券，掌握了面向对象的思想，就可以在Java世界里尽情遨游，面向对象有三大法宝和七大戒律，并在其指导下萃取出了无数的锦囊妙计和绝世武器，下面我们揭开他们的神秘面纱。 ","date":"2018-02-01","objectID":"/object-oriented/:0:0","tags":["Java基础"],"title":"Java世界的入场券-面向对象","uri":"/object-oriented/"},{"categories":["Java基础"],"content":"OOP（面向对象编程）的三大法宝 封装 封装，也就是把客观事物封装成抽象的类，并且类可以把自己的属性和方法只让可信的类操作，对不可信的类进行信息隐藏。 继承 继承是指这样一种能力，它可以使用现有的类的所有功能，并在无需重新编写原来类的情况下对这些功能进行扩展。 多态 多态指一个类实例的相同方法在不同情形有不同的表现形式。具体来说就是不同实现类对公共接口有不同的实现方式，但这些操作可以通过相同的方式（公共接口）予以调用。 ","date":"2018-02-01","objectID":"/object-oriented/:0:1","tags":["Java基础"],"title":"Java世界的入场券-面向对象","uri":"/object-oriented/"},{"categories":["Java基础"],"content":"OOD（面向对象设计）七大戒律 开-闭原则 Open-Close Principle（OCP），即开-闭原则。开，指的是对扩展开放，即要支持方便地扩展；闭，指的是对修改关闭，即要严格限制对已有内容的修改。开-闭原则是最抽象也是最重要的OOD原则。简单工厂模式、工厂方法模式、抽象工厂模式中都提到了如何通过良好的设计遵循开-闭原则。 里氏替换原则 Liskov Substitution Principle（LSP），即里氏替换原则。该原则规定“子类必须能够替换其父类，否则不应当设计为其子类”。换句话说，父类出现的地方，都应该能由其子类代替。所以，子类只能去扩展基类，而不是隐藏或者覆盖基类。 依赖倒置原则 Dependence Inversion Principle（DIP），依赖倒置原则。它讲的是“设计和实现要依赖于抽象而非具体”。一方面抽象化更符合人的思维习惯；另一方面，根据里氏替换原则，可以很容易将原来的抽象替换为扩展后的具体，这样可以很好的支持开-闭原则。 接口隔离原则 Interface Segration Principle（ISP），接口隔离原则，“将大的接口打散成多个小的独立的接口”。由于Java类支持实现多个接口，可以很容易的让类具有多种接口的特征，同时每个类可以选择性地只实现目标接口。 单一职责原则 Single Responsibility Principle（SRP），单一职责原则。它讲的是，不要存在多于一个导致类变更的原因，是高内聚低耦合的一个体现。 迪米特法则/最少知道原则 Law of Demeter or Least Knowledge Principle（LoD or LKP），迪米特法则或最少知道原则。它讲的是“一个对象就尽可能少的去了解其它对象”，从而实现松耦合。如果一个类的职责过多，由于多个职责耦合在了一起，任何一个职责的变更都可能引起其它职责的问题，严重影响了代码的可维护性和可重用性。 合成/聚合复用原则 Composite/Aggregate Reuse Principle（CARP / CRP），合成/聚合复用原则。如果新对象的某些功能在别的已经创建好的对象里面已经实现，那么应当尽量使用别的对象提供的功能，使之成为新对象的一部分，而不要再重新创建。新对象可通过向这些对象的委派达到复用已有功能的效果。简而言之，要尽量使用合成/聚合，而非使用继承。《Java设计模式（九） 桥接模式》中介绍的桥接模式即是对这一原则的典型应用。 ","date":"2018-02-01","objectID":"/object-oriented/:0:2","tags":["Java基础"],"title":"Java世界的入场券-面向对象","uri":"/object-oriented/"},{"categories":["Java基础"],"content":"行走江湖的锦囊妙计和绝世武器 上面的法宝和戒律是心法，真正行走江湖还需要趁手的兵器和锦囊妙计。 而设计模式就是应用三大法宝和七大戒律下经过反复实践铸造出来锦囊妙计和武器，具体有哪些武器我们暂且不表，毕竟倚天屠龙出世，江湖必将血雨腥风，在这之前我们还需要做好准备工作。 ","date":"2018-02-01","objectID":"/object-oriented/:0:3","tags":["Java基础"],"title":"Java世界的入场券-面向对象","uri":"/object-oriented/"},{"categories":["数据结构"],"content":"散列是数组和链表的结合体","date":"2017-02-03","objectID":"/hashtable/","tags":["数据结构"],"title":"哈希表","uri":"/hashtable/"},{"categories":["数据结构"],"content":"定义 散列Hash是和顺序、链接和索引一样，是存储集合或者线性表的一种方法。 散列的基本思想是：以集合或线性表中的每个元素的关键字K为自变量，通过一个散列函数 h(K) 得到的结果，将这个结果解释为一块连续的存储空间（如数组）的地址（如数组下标），将这个元素存储到这个空间中。 h(K) 称为散列函数或者哈希函数，它实现了关键字到存储地址的映射，散列算法，变换成固定长度的输出，该输出就是散列值。h(K)的值 称为散列地址或者哈希地址。存储空间是线性表进行散列存储的空间，所以称之为散列表或者哈希表。 ","date":"2017-02-03","objectID":"/hashtable/:1:0","tags":["数据结构"],"title":"哈希表","uri":"/hashtable/"},{"categories":["数据结构"],"content":"释义 这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 所有散列函数都有如下一个基本特性：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。 两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做碰撞，衡量一个哈希函数的好坏的重要指标就是发生碰撞的概率以及发生碰撞的解决方案。 ","date":"2017-02-03","objectID":"/hashtable/:2:0","tags":["数据结构"],"title":"哈希表","uri":"/hashtable/"},{"categories":["数据结构"],"content":"常见的Hash函数 直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址。 数字分析法：提取关键字中取值比较均匀的数字作为哈希地址。 除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址。 分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。 平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。 伪随机数法：采用一个伪随机数当作哈希函数。 ","date":"2017-02-03","objectID":"/hashtable/:3:0","tags":["数据结构"],"title":"哈希表","uri":"/hashtable/"},{"categories":["数据结构"],"content":"解决碰撞方法 开放定址法：开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。 链地址法：将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。 再哈希法：当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。 建立公共溢出区：将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。 ","date":"2017-02-03","objectID":"/hashtable/:4:0","tags":["数据结构"],"title":"哈希表","uri":"/hashtable/"},{"categories":["数据结构"],"content":"散列存储的缺点 计算散列地址需要花费时间，关键字不是整数还先要转换为整数。 占用更多的存储空间，开放定址法的装载因子小于1，链接法则需要空间存储指针。 只能按关键字查找，无法按非关键字查找。 ","date":"2017-02-03","objectID":"/hashtable/:5:0","tags":["数据结构"],"title":"哈希表","uri":"/hashtable/"},{"categories":["数据结构"],"content":"数组是用于储存多个相同类型数据的集合","date":"2017-02-02","objectID":"/linkedlist/","tags":["数据结构"],"title":"链表","uri":"/linkedlist/"},{"categories":["数据结构"],"content":"定义 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 ","date":"2017-02-02","objectID":"/linkedlist/:1:0","tags":["数据结构"],"title":"链表","uri":"/linkedlist/"},{"categories":["数据结构"],"content":"详解 链表的存在就是为了解决数组的增删复杂耗时，内存占用较大的问题。它并不需要一块连续的内存空间，它通过指针将一组零散的内存块串联起来。 根据指针的不同，有单链表，双向链表，循环链表之分。 数组和链表是相互补充的一对数据结构。 ","date":"2017-02-02","objectID":"/linkedlist/:2:0","tags":["数据结构"],"title":"链表","uri":"/linkedlist/"},{"categories":["数据结构"],"content":"优点： 操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。 链表因为元素不连续，而是靠指针指向下一个元素的位置，本身没有大小的限制，不存在数组的扩容问题，所以天然地支持动态扩容。 ","date":"2017-02-02","objectID":"/linkedlist/:3:0","tags":["数据结构"],"title":"链表","uri":"/linkedlist/"},{"categories":["数据结构"],"content":"缺点： 因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问。 由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。 同时内存不连续，容易造成内存碎片。 ","date":"2017-02-02","objectID":"/linkedlist/:4:0","tags":["数据结构"],"title":"链表","uri":"/linkedlist/"},{"categories":["数据结构"],"content":"对比 数组 数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难。 链表 链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：寻址困难，插入和删除容易。 哈希表 那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？这就是我们要提起的哈希表。 ","date":"2017-02-02","objectID":"/linkedlist/:5:0","tags":["数据结构"],"title":"链表","uri":"/linkedlist/"},{"categories":["理财"],"content":"投资纲领","date":"2016-01-01","objectID":"/investment/","tags":["理财"],"title":"投资纲领","uri":"/investment/"},{"categories":["理财"],"content":"总体策略 低估加倍 高估不买 高估卖出 好资产 + 好价格 + 长期持有 ","date":"2016-01-01","objectID":"/investment/:1:0","tags":["理财"],"title":"投资纲领","uri":"/investment/"},{"categories":["理财"],"content":"资产配置 ","date":"2016-01-01","objectID":"/investment/:2:0","tags":["理财"],"title":"投资纲领","uri":"/investment/"},{"categories":["理财"],"content":"购买标的 ","date":"2016-01-01","objectID":"/investment/:3:0","tags":["理财"],"title":"投资纲领","uri":"/investment/"},{"categories":["理财"],"content":"宽基指数（沪深300和中证500） 我们可以把沪深300和中证500这样的宽基指数作为「核心」资产，比如占整体仓位的 60% 以上，保证我们能够跟上中国经济的增长，投资到未来头部的公司。 40% 基于估值和增强型指数基金进一步提高仓位。 ","date":"2016-01-01","objectID":"/investment/:3:1","tags":["理财"],"title":"投资纲领","uri":"/investment/"},{"categories":["理财"],"content":"「卫星」资产 我们可以根据自己的判断或者市场的估值，加入一部分「卫星」资产。 主动基金（优秀基金精力管理的基金）中概互联基金 科创板（还需观看） 。 30% 分散投资给几个优秀的主动型基金经理。 ","date":"2016-01-01","objectID":"/investment/:3:2","tags":["理财"],"title":"投资纲领","uri":"/investment/"},{"categories":["理财"],"content":"债券 30% 的债券仓位，用债券基金以及有知有行未来推荐的其它「固收+」产品来进一步提高收益。 计算得出年化收益率：40% * 13% + 30% * 11% + 30% * 4% + 1% = 10.7%。 ","date":"2016-01-01","objectID":"/investment/:3:3","tags":["理财"],"title":"投资纲领","uri":"/investment/"},{"categories":["理财"],"content":"具体操作 ","date":"2016-01-01","objectID":"/investment/:4:0","tags":["理财"],"title":"投资纲领","uri":"/investment/"},{"categories":["理财"],"content":"每年一次大额买入 参考有知有行的「股市温度计」来确定自己一次性买入的仓位。 假如当年大额资金5万，当时股市温度为40处于中估状态，则先投入50%，计算得出当年大额买入资金为2.5万。 ","date":"2016-01-01","objectID":"/investment/:4:1","tags":["理财"],"title":"投资纲领","uri":"/investment/"},{"categories":["理财"],"content":"每年一次的再平衡 根据自定的家庭资产比例和当年股债实时状态，进行股债再平衡调整。 ","date":"2016-01-01","objectID":"/investment/:4:2","tags":["理财"],"title":"投资纲领","uri":"/investment/"},{"categories":["理财"],"content":"每月定投 参考有知有行的「股市温度计」，在中估时投入，低估时加倍，高估时停止买入 ","date":"2016-01-01","objectID":"/investment/:4:3","tags":["理财"],"title":"投资纲领","uri":"/investment/"},{"categories":["理财"],"content":"高估状态卖出部分锁定收益 A股的波动大，牛市之后往往出现暴跌，而浮亏越大，回本难度越大，甚至难度是呈指数级增长的。 ","date":"2016-01-01","objectID":"/investment/:4:4","tags":["理财"],"title":"投资纲领","uri":"/investment/"},{"categories":["反思"],"content":"写作促进思考","date":"2015-01-02","objectID":"/studyandthink/","tags":["反思"],"title":"学与思","uri":"/studyandthink/"},{"categories":["反思"],"content":"学而不思则罔，思而不学则殆 一味学习而不思考，就会因为不能深刻理解而不能合理有效利用学习的知识，甚至会陷入迷茫。 一味空想而不去进行实实在在地学习和钻研，则终究是沙上建塔，一无所得。 因此我们只有把学习和思考结合起来，才能学到切实有用的知识，否则就会收效甚微。 ","date":"2015-01-02","objectID":"/studyandthink/:0:0","tags":["反思"],"title":"学与思","uri":"/studyandthink/"},{"categories":["记录"],"content":"Markdown常用语法","date":"2015-01-01","objectID":"/mdgrammar/","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"标题 #### 这是 H5 #### 这是 H5 ","date":"2015-01-01","objectID":"/mdgrammar/:0:1","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"段落 这是一个段落。 这是另一个段落。 这是一个段落。 这是另一个段落。 ","date":"2015-01-01","objectID":"/mdgrammar/:0:2","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"斜体 *这是斜体* 这是斜体 ","date":"2015-01-01","objectID":"/mdgrammar/:0:3","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"粗体 **这是粗体** 这是粗体 ","date":"2015-01-01","objectID":"/mdgrammar/:0:4","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"粗体+斜体 ***这是粗体+斜体*** 这是粗体+斜体 ","date":"2015-01-01","objectID":"/mdgrammar/:0:5","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"删除线 ~~没有价值就会被抛弃~~ 没有价值就会被抛弃 ","date":"2015-01-01","objectID":"/mdgrammar/:0:6","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"引用 \u003e Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 ","date":"2015-01-01","objectID":"/mdgrammar/:0:7","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"列表 * 学习 * 思考 * 创造 学习 思考 创造 ","date":"2015-01-01","objectID":"/mdgrammar/:0:8","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"有序列表 1. 昨夜西风凋碧树。独上高楼，望尽天涯路。 2. 衣带渐宽终不悔，为伊消得人憔悴。 3. 众里寻他千百度。蓦然回首，那人却在，灯火阑珊处。 昨夜西风凋碧树。独上高楼，望尽天涯路。 衣带渐宽终不悔，为伊消得人憔悴。 众里寻他千百度。蓦然回首，那人却在，灯火阑珊处。 ","date":"2015-01-01","objectID":"/mdgrammar/:0:9","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"分隔线 --------------------------------------- ","date":"2015-01-01","objectID":"/mdgrammar/:0:10","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"链接 [百度](http://www.baidu.com/ \"百度一下\") 百度 ","date":"2015-01-01","objectID":"/mdgrammar/:0:11","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"表格 | 账户 | 余额 | 类别 | | :------- | ----: | :---: | | 人民币 | 5百万 | 活期 | | 比特币 | 5个 | 数字资产 | | 股票基金 | 5亿 | 理财 | 账户 余额 类别 人民币 5百万 活期 比特币 5个 数字资产 股票基金 5亿 理财 ","date":"2015-01-01","objectID":"/mdgrammar/:0:12","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"代码区域（四个空格） /** 这是一个Java代码区块 */ public static void main(String[] args) { System.out.println(\"Hello World\"); } ","date":"2015-01-01","objectID":"/mdgrammar/:0:13","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["记录"],"content":"图像 ![星辰大海](/images/star.png) ","date":"2015-01-01","objectID":"/mdgrammar/:0:14","tags":["Markdown"],"title":"Markdown语法","uri":"/mdgrammar/"},{"categories":["反思"],"content":"舒缓生活","date":"2015-01-01","objectID":"/energy/","tags":["生活"],"title":"减缓焦虑，积聚生活正能量","uri":"/energy/"},{"categories":["反思"],"content":" 面对不断袭来的压力和信息，我们要做的，就是找到自己的节奏，建立一套稳定的模式，用来应对和处理种种事务。尽可能让一切「平稳」下来。 这也许需要一些取舍，一些选择、牺牲和放弃 —— 但一旦这套模式能够建立起来，一切都是值得的。 ","date":"2015-01-01","objectID":"/energy/:0:0","tags":["生活"],"title":"减缓焦虑，积聚生活正能量","uri":"/energy/"},{"categories":["反思"],"content":"思虑过载 变被动为主动，自己去决定「我要做什么」，重新找回「自主性」。 ","date":"2015-01-01","objectID":"/energy/:1:0","tags":["生活"],"title":"减缓焦虑，积聚生活正能量","uri":"/energy/"},{"categories":["反思"],"content":"前一天晚上做好安排 整理一遍任务清单，从收集/待办的池子中， 挑出5-6个最重要、最关键的任务，安排到第二天 ","date":"2015-01-01","objectID":"/energy/:1:1","tags":["生活"],"title":"减缓焦虑，积聚生活正能量","uri":"/energy/"},{"categories":["反思"],"content":"留出一定的宽裕度 做出取舍。该舍弃的，就果断舍弃。 与其把所有事情做到60分，不如把最重要的事情做到100分。 ","date":"2015-01-01","objectID":"/energy/:1:2","tags":["生活"],"title":"减缓焦虑，积聚生活正能量","uri":"/energy/"},{"categories":["反思"],"content":"聚焦在长期价值上 不妨这样问问自己：我可以做些什么，来摆脱目前这种忙碌的状态？ 无论是设计一套流程，还是把部分工作委托出去，又或者是把细碎的任务合并起来，还是优化、压缩任务步骤和时间……这些，长期来看都是更具价值的，也是你应该着重去聚焦的。 把它们作为你每天「最重要的事项」，想办法让自己能够抽身出来。 ","date":"2015-01-01","objectID":"/energy/:1:3","tags":["生活"],"title":"减缓焦虑，积聚生活正能量","uri":"/energy/"},{"categories":["反思"],"content":"被压榨感 什么是被压榨感？它是指：自己一直在劳动和付出，但却始终得不到反馈、认可和肯定，仿佛自己的付出都是无价值的。 去发现生活中微小的幸福感。 ","date":"2015-01-01","objectID":"/energy/:2:0","tags":["生活"],"title":"减缓焦虑，积聚生活正能量","uri":"/energy/"},{"categories":["反思"],"content":"决策疲劳 不要在晚上作出重要的决定。 通过给自己设立规则，让规则帮助自己作出决策。规则覆盖不到的地方，则用随机来解决。 ","date":"2015-01-01","objectID":"/energy/:3:0","tags":["生活"],"title":"减缓焦虑，积聚生活正能量","uri":"/energy/"},{"categories":["反思"],"content":"外在打扰 ","date":"2015-01-01","objectID":"/energy/:4:0","tags":["生活"],"title":"减缓焦虑，积聚生活正能量","uri":"/energy/"},{"categories":["反思"],"content":"建立你的「第二大脑」，把思维外部化。 ","date":"2015-01-01","objectID":"/energy/:5:0","tags":["生活"],"title":"减缓焦虑，积聚生活正能量","uri":"/energy/"},{"categories":["反思"],"content":"信息过载 我们不断去追逐新信息，不断获取新鲜感的刺激，这本身是一个高耗能的行为 —— 但我们的大脑，会受到新鲜感的蛊惑，从而忽略和掩盖住这种耗能。 意识地克制自己，去做好信息的「反刍」，而非追逐新的信息。 试着把你记录的不同笔记放到一起，看看它们之间能产生什么联系，能否创造出新的火花。 在闲暇的碎片时间里，去反刍、回想自己记下的旧内容，尽量控制对新信息的摄入。 ","date":"2015-01-01","objectID":"/energy/:6:0","tags":["生活"],"title":"减缓焦虑，积聚生活正能量","uri":"/energy/"},{"categories":["反思"],"content":"tips 一定要睡好。 睡眠过程中的深度睡眠，能够有效促进腺苷到ATP的水合反应，为我们的机体储存能量、清除代谢垃圾。 请保证每天6小时以上不受干扰的睡眠，这极其重要。 多散步。 散步是最轻松有效的锻炼。不但能够促进血清素的合成，也能有效扩充大脑容量。波士顿大学的一项研究表明，每天步行1小时（约5000步），相当于大脑延缓衰老1年。 适当的运动。 每周 150 分钟一定强度的运动，能够有效提高心肺功能，从而提高每一天精力的上限。 这才是精力管理的关键 —— 上限太低，再怎么「管理」，也是无效的。 ","date":"2015-01-01","objectID":"/energy/:7:0","tags":["生活"],"title":"减缓焦虑，积聚生活正能量","uri":"/energy/"},{"categories":null,"content":"默哥","date":"2020-01-01","objectID":"/about/","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"用写作触发思考。 ","date":"2020-01-01","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"记录点滴，反哺归真","date":"0001-01-01","objectID":"/archives/","tags":null,"title":"归档","uri":"/archives/"},{"categories":null,"content":"搜索页面","date":"0001-01-01","objectID":"/search/","tags":null,"title":"搜索","uri":"/search/"}]