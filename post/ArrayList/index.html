<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta name="referrer" content="no-referrer-when-downgrade">
    

    <title>ArrayList详解 | 追求卓越，幸福就会不期而遇</title>
    <meta property="og:title" content="ArrayList详解 - 追求卓越，幸福就会不期而遇">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2018-03-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2018-03-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="[]">
    <meta name="description" content="ArrayList详解">
        <meta name="author" content="默哥">
        
    <meta property="og:url" content="https://moge.fun/post/ArrayList/">
    <link rel="shortcut icon" href='/favicon.ico'  type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
        <link rel="stylesheet" href='/css/douban.css'>
    
        <link rel="stylesheet" href='/css/other.css'>
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://moge.fun">
                        追求卓越，幸福就会不期而遇
                    </a>
                
                <p class="description">汝需自取真经</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://moge.fun">首页</a>
                    
                    <a  href="https://moge.fun/archives/" title="归档">归档</a>
                    
                    <a  href="https://moge.fun/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">ArrayList详解</h1>
        </header>
        <date class="post-meta meta-date">
            2018年3月2日
        </date>
        
        <div class="post-meta">
            <span>|</span>
            
            <span class="meta-category"><a href='/categories/Java%E5%9F%BA%E7%A1%80'>Java基础</a></span>
            
        </div>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            <h2 id="arraylist-简介">ArrayList 简介</h2>

<p>ArrayList 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用ensureCapacity操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。</p>

<h2 id="arraylist-核心源码解读">ArrayList 核心源码解读</h2>
<pre><code>package java.util;

import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;


public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
{
private static final long serialVersionUID = 8683452581122892189L;

/**
    * 默认初始容量大小
    */
private static final int DEFAULT_CAPACITY = 10;

/**
    * 空数组（用于空实例）。
    */
private static final Object[] EMPTY_ELEMENTDATA = {};

    //用于默认大小空实例的共享空数组实例。
    //我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

/**
    * 保存ArrayList数据的数组
    */
transient Object[] elementData; // non-private to simplify nested class access

/**
    * ArrayList 所包含的元素个数
    */
private int size;

/**
    * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）
    */
public ArrayList(int initialCapacity) {
    if (initialCapacity &gt; 0) {
        //如果传入的参数大于0，创建initialCapacity大小的数组
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {
        //如果传入的参数等于0，创建空数组
        this.elementData = EMPTY_ELEMENTDATA;
    } else {
        //其他情况，抛出异常
        throw new IllegalArgumentException(&#34;Illegal Capacity: &#34;+
                                            initialCapacity);
    }
}

/**
    *默认无参构造函数
    *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10
    */
public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}

/**
    * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。
    */
public ArrayList(Collection&lt;? extends E&gt; c) {
    //将指定集合转换为数组
    elementData = c.toArray();
    //如果elementData数组的长度不为0
    if ((size = elementData.length) != 0) {
        // 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）
        if (elementData.getClass() != Object[].class)
            //将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组
            elementData = Arrays.copyOf(elementData, size, Object[].class);
    } else {
        // 其他情况，用空数组代替
        this.elementData = EMPTY_ELEMENTDATA;
    }
}

/**
    * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。
    */
public void trimToSize() {
    modCount++;
    if (size &lt; elementData.length) {
        elementData = (size == 0)
            ? EMPTY_ELEMENTDATA
            : Arrays.copyOf(elementData, size);
    }
}
//下面是ArrayList的扩容机制
//ArrayList的扩容机制提高了性能，如果每次只扩充一个，
//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。
/**
    * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量
    * @param   minCapacity   所需的最小容量
    */
public void ensureCapacity(int minCapacity) {
    //如果是true，minExpand的值为0，如果是false,minExpand的值为10
    int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
        // any size if not default element table
        ? 0
        // larger than default for default empty table. It&#39;s already
        // supposed to be at default size.
        : DEFAULT_CAPACITY;
    //如果最小容量大于已有的最大容量
    if (minCapacity &gt; minExpand) {
        ensureExplicitCapacity(minCapacity);
    }
}
//得到最小扩容量
private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            // 获取“默认的容量”和“传入参数”两者之间的最大值
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }

    ensureExplicitCapacity(minCapacity);
}
//判断是否需要扩容
private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // overflow-conscious code
    if (minCapacity - elementData.length &gt; 0)
        //调用grow方法进行扩容，调用此方法代表已经开始扩容了
        grow(minCapacity);
}

/**
    * 要分配的最大数组大小
    */
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

/**
    * ArrayList扩容的核心方法。
    */
private void grow(int minCapacity) {
    // oldCapacity为旧容量，newCapacity为新容量
    int oldCapacity = elementData.length;
    //将oldCapacity 右移一位，其效果相当于oldCapacity /2，
    //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    //再检查新容量是否超出了ArrayList所定义的最大容量，
    //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，
    //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
//比较minCapacity和 MAX_ARRAY_SIZE
private static int hugeCapacity(int minCapacity) {
    if (minCapacity &lt; 0) // overflow
        throw new OutOfMemoryError();
    return (minCapacity &gt; MAX_ARRAY_SIZE) ?
        Integer.MAX_VALUE :
        MAX_ARRAY_SIZE;
}

/**
    *返回此列表中的元素数。
    */
public int size() {
    return size;
}

/**
    * 如果此列表不包含元素，则返回 true 。
    */
public boolean isEmpty() {
    //注意=和==的区别
    return size == 0;
}

/**
    * 如果此列表包含指定的元素，则返回true 。
    */
public boolean contains(Object o) {
    //indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1
    return indexOf(o) &gt;= 0;
}

/**
    *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1
    */
public int indexOf(Object o) {
    if (o == null) {
        for (int i = 0; i &lt; size; i++)
            if (elementData[i]==null)
                return i;
    } else {
        for (int i = 0; i &lt; size; i++)
            //equals()方法比较
            if (o.equals(elementData[i]))
                return i;
    }
    return -1;
}

/**
    * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.
    */
public int lastIndexOf(Object o) {
    if (o == null) {
        for (int i = size-1; i &gt;= 0; i--)
            if (elementData[i]==null)
                return i;
    } else {
        for (int i = size-1; i &gt;= 0; i--)
            if (o.equals(elementData[i]))
                return i;
    }
    return -1;
}

/**
    * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）
    */
public Object clone() {
    try {
        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();
        //Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度
        v.elementData = Arrays.copyOf(elementData, size);
        v.modCount = 0;
        return v;
    } catch (CloneNotSupportedException e) {
        // 这不应该发生，因为我们是可以克隆的
        throw new InternalError(e);
    }
}

/**
    *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。
    *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。
    *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。
    */
public Object[] toArray() {
    return Arrays.copyOf(elementData, size);
}

/**
    * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;
    *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。
    *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。
    *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。
    *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）
    */
@SuppressWarnings(&#34;unchecked&#34;)
public &lt;T&gt; T[] toArray(T[] a) {
    if (a.length &lt; size)
        // 新建一个运行时类型的数组，但是ArrayList数组的内容
        return (T[]) Arrays.copyOf(elementData, size, a.getClass());
        //调用System提供的arraycopy()方法实现数组之间的复制
    System.arraycopy(elementData, 0, a, 0, size);
    if (a.length &gt; size)
        a[size] = null;
    return a;
}

// Positional Access Operations

@SuppressWarnings(&#34;unchecked&#34;)
E elementData(int index) {
    return (E) elementData[index];
}

/**
    * 返回此列表中指定位置的元素。
    */
public E get(int index) {
    rangeCheck(index);

    return elementData(index);
}

/**
    * 用指定的元素替换此列表中指定位置的元素。
    */
public E set(int index, E element) {
    //对index进行界限检查
    rangeCheck(index);

    E oldValue = elementData(index);
    elementData[index] = element;
    //返回原来在这个位置的元素
    return oldValue;
}

/**
    * 将指定的元素追加到此列表的末尾。
    */
public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    //这里看到ArrayList添加元素的实质就相当于为数组赋值
    elementData[size++] = e;
    return true;
}

/**
    * 在此列表中的指定位置插入指定的元素。
    *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；
    *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。
    */
public void add(int index, E element) {
    rangeCheckForAdd(index);

    ensureCapacityInternal(size + 1);  // Increments modCount!!
    //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；
    System.arraycopy(elementData, index, elementData, index + 1,
                        size - index);
    elementData[index] = element;
    size++;
}

/**
    * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。
    */
public E remove(int index) {
    rangeCheck(index);

    modCount++;
    E oldValue = elementData(index);

    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index,
                            numMoved);
    elementData[--size] = null; // clear to let GC do its work
    //从列表中删除的元素
    return oldValue;
}

/**
    * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。
    *返回true，如果此列表包含指定的元素
    */
public boolean remove(Object o) {
    if (o == null) {
        for (int index = 0; index &lt; size; index++)
            if (elementData[index] == null) {
                fastRemove(index);
                return true;
            }
    } else {
        for (int index = 0; index &lt; size; index++)
            if (o.equals(elementData[index])) {
                fastRemove(index);
                return true;
            }
    }
    return false;
}

/*
    * Private remove method that skips bounds checking and does not
    * return the value removed.
    */
private void fastRemove(int index) {
    modCount++;
    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index,
                            numMoved);
    elementData[--size] = null; // clear to let GC do its work
}

/**
    * 从列表中删除所有元素。
    */
public void clear() {
    modCount++;

    // 把数组中所有的元素的值设为null
    for (int i = 0; i &lt; size; i++)
        elementData[i] = null;

    size = 0;
}

/**
    * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。
    */
public boolean addAll(Collection&lt;? extends E&gt; c) {
    Object[] a = c.toArray();
    int numNew = a.length;
    ensureCapacityInternal(size + numNew);  // Increments modCount
    System.arraycopy(a, 0, elementData, size, numNew);
    size += numNew;
    return numNew != 0;
}

/**
    * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。
    */
public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
    rangeCheckForAdd(index);

    Object[] a = c.toArray();
    int numNew = a.length;
    ensureCapacityInternal(size + numNew);  // Increments modCount

    int numMoved = size - index;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index, elementData, index + numNew,
                            numMoved);

    System.arraycopy(a, 0, elementData, index, numNew);
    size += numNew;
    return numNew != 0;
}

/**
    * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。
    *将任何后续元素移动到左侧（减少其索引）。
    */
protected void removeRange(int fromIndex, int toIndex) {
    modCount++;
    int numMoved = size - toIndex;
    System.arraycopy(elementData, toIndex, elementData, fromIndex,
                        numMoved);

    // clear to let GC do its work
    int newSize = size - (toIndex-fromIndex);
    for (int i = newSize; i &lt; size; i++) {
        elementData[i] = null;
    }
    size = newSize;
}

/**
    * 检查给定的索引是否在范围内。
    */
private void rangeCheck(int index) {
    if (index &gt;= size)
        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
}

/**
    * add和addAll使用的rangeCheck的一个版本
    */
private void rangeCheckForAdd(int index) {
    if (index &gt; size || index &lt; 0)
        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
}

/**
    * 返回IndexOutOfBoundsException细节信息
    */
private String outOfBoundsMsg(int index) {
    return &#34;Index: &#34;+index+&#34;, Size: &#34;+size;
}

/**
    * 从此列表中删除指定集合中包含的所有元素。
    */
public boolean removeAll(Collection&lt;?&gt; c) {
    Objects.requireNonNull(c);
    //如果此列表被修改则返回true
    return batchRemove(c, false);
}

/**
    * 仅保留此列表中包含在指定集合中的元素。
    *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。
    */
public boolean retainAll(Collection&lt;?&gt; c) {
    Objects.requireNonNull(c);
    return batchRemove(c, true);
}


/**
    * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。
    *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。
    *返回的列表迭代器是fail-fast 。
    */
public ListIterator&lt;E&gt; listIterator(int index) {
    if (index &lt; 0 || index &gt; size)
        throw new IndexOutOfBoundsException(&#34;Index: &#34;+index);
    return new ListItr(index);
}

/**
    *返回列表中的列表迭代器（按适当的顺序）。
    *返回的列表迭代器是fail-fast 。
    */
public ListIterator&lt;E&gt; listIterator() {
    return new ListItr(0);
}

/**
    *以正确的顺序返回该列表中的元素的迭代器。
    *返回的迭代器是fail-fast 。
    */
public Iterator&lt;E&gt; iterator() {
    return new Itr();
}</code></pre>
        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/post/JavaContainer/">Java容器概览</a></li>
        
        <li><a href="/post/LinkedList/">链表</a></li>
        
        <li><a href="/post/Array/">数组</a></li>
        
        <li><a href="/post/reflection/">框架的灵魂-反射</a></li>
        
        <li><a href="/post/generic/">Java特性-泛型</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84'>数据结构</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "alatan/BlogDiscuss"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2021 <a href="https://moge.fun">追求卓越，幸福就会不期而遇 By 默哥</a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




    <script src='/js/douban.js'></script>

                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://moge.fun/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://moge.fun">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://moge.fun/post/SpringCloudAlibaba/" title="微服务方案SpringCloudAlibaba">微服务方案SpringCloudAlibaba</a>
    </li>
    
    <li>
        <a href="https://moge.fun/post/distributed/" title="分布式介绍">分布式介绍</a>
    </li>
    
    <li>
        <a href="https://moge.fun/post/JavaArchHistory/" title="Java架构演变历史">Java架构演变历史</a>
    </li>
    
    <li>
        <a href="https://moge.fun/post/JavaOutline/" title="Java知识大纲">Java知识大纲</a>
    </li>
    
    <li>
        <a href="https://moge.fun/post/ConcurrentHashMap/" title="ConcurrentHashMap详解">ConcurrentHashMap详解</a>
    </li>
    
    <li>
        <a href="https://moge.fun/post/JavaCurrent/" title="Java并发编程概览">Java并发编程概览</a>
    </li>
    
    <li>
        <a href="https://moge.fun/post/HashMap/" title="HashMap详解">HashMap详解</a>
    </li>
    
    <li>
        <a href="https://moge.fun/post/ArrayList/" title="ArrayList详解">ArrayList详解</a>
    </li>
    
    <li>
        <a href="https://moge.fun/post/JavaContainer/" title="Java容器概览">Java容器概览</a>
    </li>
    
    <li>
        <a href="https://moge.fun/post/reflection/" title="框架的灵魂-反射">框架的灵魂-反射</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href='/categories/'>分类</a></h3>
<ul class="widget-list">
    
    <li><a href="https://moge.fun/categories/Java%E5%9F%BA%E7%A1%80/">Java基础 (8)</a></li>
    
    <li><a href="https://moge.fun/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式 (1)</a></li>
    
    <li><a href="https://moge.fun/categories/%E5%8F%8D%E6%80%9D/">反思 (2)</a></li>
    
    <li><a href="https://moge.fun/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务 (1)</a></li>
    
    <li><a href="https://moge.fun/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构 (3)</a></li>
    
    <li><a href="https://moge.fun/categories/%E7%90%86%E8%B4%A2/">理财 (1)</a></li>
    
    <li><a href="https://moge.fun/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">知识体系 (2)</a></li>
    
    <li><a href="https://moge.fun/categories/%E8%AE%B0%E5%BD%95/">记录 (1)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/tags/'>标签</a></h3>
<div class="tagcloud">
    
    <a href="https://moge.fun/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
    
    <a href="https://moge.fun/tags/Markdown/">Markdown</a>
    
    <a href="https://moge.fun/tags/SpringCloud/">SpringCloud</a>
    
    <a href="https://moge.fun/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
    
    <a href="https://moge.fun/tags/%E5%8F%8D%E6%80%9D/">反思</a>
    
    <a href="https://moge.fun/tags/%E5%A4%A7%E7%BA%B2/">大纲</a>
    
    <a href="https://moge.fun/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a>
    
    <a href="https://moge.fun/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    
    <a href="https://moge.fun/tags/%E7%90%86%E8%B4%A2/">理财</a>
    
    <a href="https://moge.fun/tags/%E7%94%9F%E6%B4%BB/">生活</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://moge.fun/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>