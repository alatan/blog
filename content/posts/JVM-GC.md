---  
title: "JVM-GC垃圾收集器"  
date: 2018-05-05
weight: 70  
draft: false  
keywords: [""]  
description: "JVM-GC垃圾收集器"  
tags: ["JVM"]
categories: ["JVM"]  
author: "默哥"  

lightgallery: true

toc:
  auto: false
---

## Java垃圾回收
### 判断一个对象是否可被回收
#### 引用计数算法
给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。 两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。 正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。
#### 可达性分析算法
通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收，Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容: 
* 虚拟机栈中引用的对象 
* 本地方法栈中引用的对象 
* 方法区中类静态属性引用的对象 
* 方法区中的常量引用的对象

#### 方法区的回收
因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，因此在方法区上进行回收性价比不高。

主要是对常量池的回收和对类的卸载，在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。 

类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载: 
* 该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。 
* 加载该类的 ClassLoader 已经被回收。
* 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。

#### finalize()
finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。 

当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法。

### 垃圾回收算法
#### 标记 - 清除
> 将存活的对象进行标记，然后清理掉未被标记的对象。

不足:
* 标记和清除过程效率都不高；
* 会产生大量不连续的内存碎片，导致无法给大对象分配内存。

#### 标记 - 整理
> 让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

#### 复制
> 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 

主要不足是只使用了内存的一半。 

现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。 

HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。

#### 分代收集
> 现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。 

一般将堆分为新生代和老年代。 
* 新生代使用: 复制算法 
* 老年代使用: 标记 - 清除 或者 标记 - 整理 算法

###  垃圾收集器
![](/images/jvm/gc.png "垃圾收集器")

![](/images/jvm/gc-vs.jpg "垃圾收集器对比")

### 内存分配与回收策略
#### Minor GC 和 Full GC
* Minor GC: 发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。 
* Full GC: 发生在老年代上，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。 

针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full  GC） 

* 部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为：
  * 新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集 
  * 老年代收集（Major GC/Old GC）：只是老年代的垃圾收集
    * 目前，只有 CMS GC 会有单独收集老年代的行为 
    * 很多时候 Major GC 会和 Full GC  混合使用，需要具体分辨是老年代回收还是整堆回收 
  * 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集
    * 目前只有 G1 GC 会有这种行为 
* 整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾