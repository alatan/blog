#### 对象在堆中的生命周期
1. 在 JVM 内存模型的堆中，堆被划分为新生代和老年代
  * 新生代又被进一步划分为 Eden区 和 Survivor区，Survivor 区由 From Survivor 和 To Survivor 组成 
2. 当创建一个对象时，对象会被优先分配到新生代的 Eden 区
  * 此时 JVM 会给对象定义一个对象年轻计数器（-XX:MaxTenuringThreshold） 
3. 当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC）
  * JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1 
  * 对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会+1 
4. 如果分配的对象超过了-XX:PetenureSizeThreshold，对象会直接被分配到老年代 

#### 对象的分配过程
为对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法和内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。 
1. new 的对象先放在伊甸园区，此区有大小限制 
2. 当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区 
3. 然后将伊甸园中的剩余对象移动到幸存者 0 区 
4. 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区，如果没有回收，就会放到幸存者 1 区 
5. 如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区 
6. 什么时候才会去养老区呢？ 默认是 15 次回收标记 
7. 在养老区，相对悠闲。当养老区内存不足时，再次触发 Major GC，进行养老区的内存清理 
8. 若养老区执行了 Major GC  之后发现依然无法进行对象的保存，就会产生 OOM 异常
