---  
title: "关系型数据库概览"
description: "关系型数据库概览"
keywords: ["数据库"]
date: 2017-03-01
author: "默哥"
weight: 70
draft: false

categories: ["数据库"]
tags: ["数据库", "大纲"]  
toc: 
    auto: false
---

![](/images/db/db.png "数据库总览")

![](/images/db/rdb/sqlDB.png "SQL数据库原理")

## 数据库组件
![](/images/db/rdb/allComponent.png "SQL数据库概览")

### 核心组件
* 进程管理器（process manager）：很多数据库具备一个需要妥善管理的进程/线程池。再者，为了实现纳秒级操作，一些现代数据库使用自己的线程而不是操作系统线程。 
* 网络管理器（network manager）：网路I/O是个大问题，尤其是对于分布式数据库。所以一些数据库具备自己的网络管理器。 
* 文件系统管理器（File system manager）：磁盘I/O是数据库的首要瓶颈。具备一个文件系统管理器来完美地处理OS文件系统甚至取代OS文件系统，是非常重要的。 
* 内存管理器（memory manager）：为了避免磁盘I/O带来的性能损失，需要大量的内存。但是如果你要处理大容量内存你需要高效的内存管理器，尤其是你有很多查询同时使用内存的时候。 
* 安全管理器（Security Manager）：用于对用户的验证和授权。 
* 客户端管理器（Client manager）：用于管理客户端连接。

### 工具 
* 备份管理器（Backup manager）：用于保存和恢复数据。 
* 恢复管理器（Recovery manager）：用于崩溃后重启数据库到一个一致状态。 
* 监控管理器（Monitor manager）：用于记录数据库活动信息和提供监控数据库的工具。 
* 管理员管理器（Administration manager）：用于保存元数据（比如表的名称和结构），提供管理数据库、模式、表空间的工具。

### 查询管理器 
* 查询解析器（Query parser）：用于检查查询是否合法 
* 查询重写器（Query rewriter）：用于预优化查询 
* 查询优化器（Query optimizer）：用于优化查询 
* 查询执行器（Query executor）：用于编译和执行查询

### 数据管理器： 
* 事务管理器（Transaction manager）：用于处理事务 
* 缓存管理器（Cache manager）：数据被使用之前置于内存，或者数据写入磁盘之前置于内存 
* 数据访问管理器（Data access manager）：访问磁盘中的数据

## 数据查询的流程
本章集中探讨数据库如何通过如下进程管理SQL查询的：
1. 客户端管理器
2. 查询管理器
3. 数据管理器（含恢复管理器）
4. 客户端管理器

### 客户端管理器
> 客户端管理器是处理客户端通信的。客户端可以是一个（网站）服务器或者一个最终用户或最终应用。客户端管理器通过一系列知名的API（JDBC, ODBC, OLE-DB …）提供不同的方式来访问数据库。客户端管理器也提供专有的数据库访问API。

![](/images/db/rdb/ClientManager.png "客户端管理器")
当你连接到数据库时： 
* 管理器首先检查你的验证信息（用户名和密码），然后检查你是否有访问数据库的授权。这些权限由DBA分配。 
* 然后，管理器检查是否有空闲进程（或线程）来处理你对查询。 
* 管理器还会检查数据库是否负载很重。 
* 管理器可能会等待一会儿来获取需要的资源。如果等待时间达到超时时间，它会关闭连接并给出一个可读的错误信息。 
* 然后管理器会把你的查询送给查询管理器来处理。 
* 因为查询处理进程不是『不全则无』的，一旦它从查询管理器得到数据，它会把部分结果保存到一个缓冲区并且开始给你发送。 
* 如果遇到问题，管理器关闭连接，向你发送可读的解释信息，然后释放资源。

### 查询管理器
![](/images/db/rdb/QueryManager.png "查询管理器")
这个多步骤操作过程如下： 
* 查询首先被解析并判断是否合法 
* 然后被重写，去除了无用的操作并且加入预优化部分 
* 接着被优化以便提升性能，并被转换为可执行代码和数据访问计划。 
* 然后计划被编译 
* 最后，被执行

### 数据管理器
![](/images/db/rdb/DataManager.png "查询管理器")
在这一步，查询管理器执行了查询，需要从表和索引获取数据，于是向数据管理器提出请求。
但是有 2 个问题： 
* 关系型数据库使用事务模型，所以，当其他人在同一时刻使用或修改数据时，你无法得到这部分数据。 
* 数据提取是数据库中速度最慢的操作，所以数据管理器需要足够聪明地获得数据并保存在内存缓冲区内。

#### 缓冲区
* 缓冲池(buffer pool)是一种常见的降低磁盘访问的机制；
* 缓冲池通常以页(page)为单位缓存数据；
* 缓冲池的常见管理算法是LRU，memcache，OS，InnoDB都使用了这种算法；
* InnoDB对普通LRU进行了优化：将缓冲池分为老生代和新生代，入缓冲池的页，优先进入老生代，页被访问，才进入新生代，以解决预读失效的问题页被访问，且在老生代停留时间超过配置阈值的，才进入新生代，以解决批量数据访问，大量热数据淘汰的问题

## 核心知识点
### 事务
> 事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。
#### ACID特性
##### 原子性(Atomicity) 
事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。 回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
##### 一致性(Consistency) 
数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。 
##### 隔离性(Isolation) 
一个事务所做的修改在最终提交以前，对其它事务是不可见的。
##### 持久性(Durability) 
一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。 可以通过数据库备份和恢复来实现，在系统发生崩溃时，使用备份的数据库进行数据恢复。

#### ACID特性的相互关系
事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系: 
* 只有满足一致性，事务的执行结果才是正确的。 
* 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。 
* 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。 
* 事务满足持久化是为了能应对数据库崩溃的情况。

![](/images/db/rdb/dbc.png "ACID")

### 并发一致性问题
在并发环境下，**事务的隔离性很难保证，因此会出现很多并发一致性问题。**
#### 丢失修改
T1和T2两个事务都对一个数据进行修改，T1先修改，T2随后修改，**T2的修改覆盖了T1的修改**。
#### 读脏数据
T1修改一个数据，T2随后读取这个数据。如果**T1撤销了这次修改，那么T2读取的数据是脏数据。**
#### 不可重复读
**T2读取一个数据，T1对该数据做了修改**。如果T2再次读取这个数据，此时读取的结果和第一次读取的结果不同。
#### 幻影读
**T1读取某个范围的数据，T2在这个范围内插入新的数据，T1再次读取这个范围的数据**，此时读取的结果和和第一次读取的结果不同。

### 并发一致性的解决方案
**产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性**。并发控制可以通过封锁来实现，但是**封锁操作**需要用户自己控制，相当复杂。

**数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。**

### 隔离级别 
> 使用select @@tx_isolation;查询数据库的隔离级别。Mysql默认的级别是可重复读，优先考虑把数据库系统的隔离级别设为读已提交。

#### 未提交读(READ UNCOMMITTED) 
读未提交，一个事务可以读到另一个事务未提交的数据！
#### 提交读(READ COMMITTED) 
读已提交，一个事务可以读到另一个事务已提交的数据!
一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。 
#### 可重复读(REPEATABLE READ) 
可重复读，加入间隙锁保证在同一个事务中多次读取同样数据的结果是一样的。
#### 可串行化(SERIALIZABLE) 
串行化，该级别下读写串行化，且所有的select语句后都自动加上lock in share mode，即使用了共享锁。因此在该隔离级别下，使用的是当前读，而不是快照读。

**多版本并发控制是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式**，用于实现**提交读和可重复读这两种隔离级别**。

**而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。**

MySQL的InnoDB存储引擎**采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放**，这被称为隐式锁定。

![](/images/db/rdb/geli.png "隔离级别")

### 封锁
#### 封锁粒度
MySQL 中提供了两种封锁粒度: 行级锁以及表级锁。
![](/images/db/rdb/dblock.jpg "封锁粒度")

#### 封锁类型
##### 读写锁
* 排它锁(Exclusive)，简写为 X 锁，又称写锁。 
* 共享锁(Shared)，简写为 S 锁，又称读锁。 

有以下两个规定: 
* 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。 
* 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。

##### 意向锁
使用意向锁(Intention Locks)可以更容易地支持多粒度封锁。 

在存在行级锁和表级锁的情况下，事务T想要对表A加X锁，就需要先检测是否有其它事务对表A或者表A中的任意一行加了锁，那么就需要**对表A的每一行都检测一次，这是非常耗时的**。

意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。

* 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁； 
* 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。 
* 任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁；
* S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。

**通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表A加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务T加X锁失败。**

#### 封锁协议
##### 三级封锁协议
###### 一级封锁协议
事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。

可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。
###### 二级封锁协议 
在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。 

可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。
###### 三级封锁协议 
在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。 

可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。

##### 两段锁协议
加锁和解锁分为两个阶段进行。 

可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。 

事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。

MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。

### 多版本并发控制
> 多版本并发控制(Multi-Version Concurrency Control, MVCC)是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

#### 版本号 
* 系统版本号: 是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。 
* 事务版本号: 事务开始时的系统版本号。 

#### 隐藏的列 
MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号: 
* 创建版本号: 指示创建一个数据行的快照时的系统版本号； 
* 删除版本号: 如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。 

#### Undo 日志 
MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行(Record)的所有快照连接起来。

#### 实现过程
以下实现过程针对可重复读隔离级别。

当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。

1. SELECT 
> 多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。 把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。 

2. INSERT 
> 将当前系统版本号作为数据行快照的创建版本号。 

3. DELETE 
> 将当前系统版本号作为数据行快照的删除版本号。 

4. UPDATE 
> 将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。

#### 快照读与当前读
##### 快照读
使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。
```sql
select * from table ...;
```
##### 当前读
读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。
```sql
select * from table where ? lock in share mode; //S锁 (共享锁)
select * from table where ? for update;         //加X锁 (排他锁)
insert;
update;
delete;
```

### Next-Key Locks
> Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。 

MVCC不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。**在可重复读(REPEATABLE READ)隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。**

#### Record Locks（行锁）
锁定一个记录上的索引，而不是记录本身。 

该锁是对索引记录进行加锁！锁是在加索引上而不是行上的。注意了，innodb一定存在聚簇索引，因此行锁最终都会落到聚簇索引上！

如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。 

#### Gap Locks（间隙锁）
锁定索引之间的间隙，但是不包含索引本身。其目的只有一个，防止其他事物插入数据。

隔离级别比Read Committed低的情况下，不会使用间隙锁，如隔离级别为Read Uncommited时，也不存在间隙锁。当隔离级别为Repeatable Read和Serializable时，就会存在间隙锁。

例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。
```sql
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
```

#### Next-Key Locks
它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。

例如一个索引包含以下值: 10, 11, 13, and 20，那么就需要锁定以下区间:
```sql
(negative infinity, 10]
(10, 11]
(11, 13]
(13, 20]
(20, positive infinity)
```
### 锁行锁表
InnoDB行锁是通过给索引上的索引项加锁来实现，只有通过索引条件检索数据，InnoDB才使用行级锁，否则表锁（注意下面的解释）。

这里的表锁并不是用表锁来实现锁表的操作，而是利用了Next-Key Locks，也可以理解为是用了行锁+间隙锁来实现锁表的操作! 

之所以能够锁表，是通过行锁+间隙锁来实现的。那么，RU和RC都不存在间隙锁，这种说法在RU和RC中还能成立么？ 因此，该说法只在RR和Serializable中是成立的。
**如果隔离级别为RU和RC，无论条件列上是否有索引，都不会锁表，只锁行！**

## 参考文章
* [关系型数据库是如何工作的](https://www.pdai.tech/md/db/sql/sql-db-howitworks.html "关系型数据库是如何工作")
* [数据库系统核心知识点](https://www.pdai.tech/md/db/sql/sql-db-theory.html "数据库系统核心知识点")
* [select加锁分析](https://juejin.cn/post/6844903919387148296 "select加锁分析")
* [MySQL InnoDB的MVCC实现机制](https://www.pdai.tech/md/db/sql-mysql/sql-mysql-mvcc.html "MySQL InnoDB的MVCC实现机制")
* [一条SQL的执行过程详解](https://www.pdai.tech/md/db/sql-mysql/sql-mysql-execute.html "一条SQL的执行过程详解")