---  
title: "Redis概览"
description: "Redis概览"
keywords: ["缓存"]
date: 2017-03-05
author: "默哥"
weight: 70
draft: false

categories: ["数据库"]
tags: ["缓存", "大纲"]  
toc: 
    auto: false
---

![](/images/redis/redis-overview.png "Redis总览")

> Redis是一款内存高速缓存数据库。Redis全称为：Remote Dictionary Server（远程数据服务. ，Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。

## 基础数据类型
> Redis所有的key（键. 都是字符串。我们在谈基础数据结构时，讨论的是存储值的数据类型，主要包括常见的5种数据类型，分别是：String、List、Set、Zset、Hash

| 结构类型 |  结构存储的值 	| 结构的读写能力 |
---- | ---| ---  | 
| String字符串 	| 可以是字符串、整数或浮点数 	| 对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作；| 
| List列表 	    | 一个链表，链表上的每个节点都包含一个字符串 	| 对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；| 
| Set集合 	    | 包含字符串的无序集合 	| 字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等| 
| Hash散列 	    | 包含键值对的无序散列表 	| 包含方法有添加、获取、删除单个元素| 
| Zset有序集合 	 | 和散列一样，用于存储键值对 	| 字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素| 


## 持久化
> 为了防止数据丢失以及服务重启时能够恢复数据，Redis支持数据的持久化，主要分为两种方式，分别是RDB和AOF; 当然实际场景下还会使用这两种的混合模式

### RDB 持久化
> RDB 就是 Redis DataBase 的缩写，中文名为快照/内存快照，RDB持久化是把当前进程数据生成快照保存到磁盘上的过程，由于是某一时刻的快照，那么快照中的值要早于或者等于内存中的值。

#### 触发方式
##### 手动触发
* save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存 比较大的实例会造成长时间阻塞，线上环境不建议使用 
* bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子 进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短

bgsave命令具体流程如下： 
* redis客户端执行bgsave命令或者自动触发bgsave命令； 
* 主进程判断当前是否已经存在正在执行的子进程，如果存在，那么主进程直接返回； 
* 如果不存在正在执行的子进程，那么就fork一个新的子进程进行持久化数据，fork过程是阻塞的，fork操作完成后主进程即可执行其他操作； 
* 子进程先将数据写入到临时的rdb文件中，待快照数据写入完成后再原子替换旧的rdb文件； 
* 同时发送信号给主进程，通知主进程rdb持久化完成，主进程更新相关的统计信息（info Persitence下的rdb_*相关选项. 。 
##### 自动触发
在以下4种情况时会自动触发
* redis.conf中配置save m n，即在m秒内有n次修改时，自动触发bgsave生成rdb文件； 
* 主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点； 
* 执行debug reload命令重新加载redis时也会触发bgsave操作； 
* 默认情况下执行shutdown命令时，如果没有开启aof持久化，那么也会触发bgsave操作；

#### RDB优缺点 
##### 优点 
* RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景； 
* Redis加载RDB文件恢复数据要远远快于AOF方式； 
##### 缺点 
* RDB方式实时性不够，无法做到秒级的持久化； 
* 每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高； 
* RDB文件是二进制的，没有可读性，AOF文件在了解其结构的情况下可以手动修改或者补全； 
* 版本兼容RDB文件问题； 

### AOF 持久化
> Redis是“写后”日志，Redis先执行命令，把数据写入内存，然后才记录日志。日志里记录的是Redis收到的每一条命令，这些命令是以文本形式保存。PS: 大多数的数据库采用的是写前日志（WAL. ，例如MySQL，通过写前日志和两阶段提交，实现数据和逻辑的一致性。

### RDB和AOF混合方式（4.0版本)
Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。

### 从持久化中恢复数据
流程如下：
* redis重启时判断是否开启aof，如果开启了aof，那么就优先加载aof文件； 
* 如果aof存在，那么就去加载aof文件，加载成功的话redis重启成功，如果aof文件加载失败，那么会打印日志表示启动失败，此时可以去修复aof文件后重新启动； 
* 若aof文件不存在，那么redis就会转而去加载rdb文件，如果rdb文件不存在，redis直接启动成功； 
* 如果rdb文件存在就会去加载rdb文件恢复数据，如加载失败则打印日志提示启动失败，如加载成功，那么redis重启成功，且使用rdb文件恢复数据；

那么为什么会优先加载AOF呢？因为AOF保存的数据更完整，通过上面的分析我们知道AOF基本上最多损失1s的数据。

## Redis事务
> Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。 

总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。 

## 高可用：主从复制
> 我们知道要避免单点故障，即保证高可用，便需要冗余（副本. 方式提供集群服务。而Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式。

**主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。**
* 读操作：主库、从库都可以接收；
* 写操作：首先到主库执行，然后，主库将写操作同步给从库。


主从复制的作用主要包括：
* 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。 
* 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。 
* 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点. ，分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。 
* 高可用基石：除了上述作用以外，**主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。**

###  主从复制原理
#### 全量复制
> 当我们启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof（Redis 5.0 之前使用 slaveof. 命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。
![](/images/redis/redis-copy-all.jpg "全量复制")

#### 增量复制
![](/images/redis/redis-copy-add.jpg "增量复制")

## 高可用：哨兵机制（Redis Sentinel. 
> 如果主节点出现故障该怎么办呢？ 在 Redis 主从集群中，哨兵机制是实现主从库自动切换的关键机制，它有效地解决了主从复制模式下故障转移的问题。

主要功能：
* 监控（Monitoring. ：哨兵会不断地检查主节点和从节点是否运作正常。 
* 自动故障转移（Automatic failover. ：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。 
* 配置提供者（Configuration provider. ：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。 
* 通知（Notification. ：哨兵可以将故障转移的结果发送给客户端。

## 高可拓展：分片技术（Redis Cluster)
主从复制和哨兵机制保障了高可用，就读写分离而言虽然slave节点扩展了主从的读并发能力，但是写能力和存储能力是无法进行扩展，就只能是master节点能够承载的上限。如果面对海量数据那么必然需要构建master（主节点分片)之间的集群，同时必然需要吸收高可用（主从复制和哨兵机制. 能力，即每个master分片节点还需要有slave节点，这是分布式系统中典型的纵向扩展（集群的分片技术. 的体现；所以在Redis 3.0版本中对应的设计就是Redis Cluster。

## 缓存问题
> Redis最常用的一个场景就是作为缓存，在实践中可能会有哪些问题？比如一致性, 穿击, 穿透, 雪崩, 污染等。
### 缓存穿透
**缓存穿透是指缓存和数据库中都没有的数据**，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。

在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。

解决方案：
1. 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截； 
2. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用. 。这样可以防止攻击用户反复用同一个id暴力攻击 
3. 布隆过滤器。bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小。

### 缓存击穿
**缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期)**，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。 

解决方案 
1. 设置热点数据永远不过期。 
2. 接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些服务不可用时候，进行熔断，失败快速返回机制。 
3. 加互斥锁.

### 缓存雪崩 
**缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机**。和缓存击穿不同的是，**缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了**，很多数据都查不到从而查数据库。 

解决方案： 
1. 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。 
2. 如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。 
3. 设置热点数据永远不过期。

### 缓存污染（或满了) 
**缓存污染问题说的是缓存中一些只会被访问一次或者几次的的数据，被访问完后，再也不会被访问到，但这部分数据依然留存在缓存中，消耗缓存空间。** 

缓存污染会随着数据的持续增加而逐渐显露，随着服务的不断运行，缓存中会存在大量的永远不会再次被访问的数据。缓存空间是有限的，如果缓存空间满了，再往缓存里写数据时就会有额外开销，影响Redis性能。这部分额外开销主要是指写的时候判断淘汰策略，根据淘汰策略去选择要淘汰的数据，然后进行删除操作。

#### 缓存淘汰策略
* 不淘汰
    * noevictionv4.0后默认的。
* 对设置了过期时间的数据中进行淘汰 
    * 随机：volatile-random
    * ttl：volatile-ttl 越早过期的数据越优先被选择。
    * lru：volatile-lru LRU算法：LRU 算法的全称是 Least Recently Used，按照最近最少使用的原则来筛选数据。这种模式下会使用 LRU 算法筛选设置了过期时间的键值对。
    * lfu：volatile-lfu LFU 算法：LFU 缓存策略是在 LRU 策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。当使用 LFU 策略筛选淘汰数据时，首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出缓存。如果两个数据的访问次数相同，LFU 策略再比较这两个数据的访问时效性，把距离上一次访问时间更久的数据淘汰出缓存。
* 全部数据进行淘汰
    * 随机：allkeys-random
    * lru：allkeys-lru
    * lfu：allkeys-lfu

### 数据库和缓存一致性
#### 方案：队列 + 重试机制
流程如下所示 
* 更新数据库数据； 
* 缓存因为种种问题删除失败 
* 将需要删除的key发送至消息队列 
* 自己消费消息，获得需要删除的key 
* 继续重试删除操作，直到成功 

然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。

#### 方案：异步更新缓存(基于订阅binlog的同步机制)
MySQL binlog增量订阅消费+消息队列+增量数据更新到redis 
1. 读Redis：热数据基本都在Redis 
2. 写MySQL: 增删改都是操作MySQL 
3. 更新Redis数据：MySQL的数据操作binlog，来更新到Redis

读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。 

这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。 

其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。 

这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。

当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis。 

## 参考文章
1. [持久化](https://www.pdai.tech/md/db/nosql-redis/db-redis-x-rdb-aof.html "持久化")
2. [高可用：主从复制](https://www.pdai.tech/md/db/nosql-redis/db-redis-x-copy.html "高可用：主从复制")
3. [缓存问题](https://www.pdai.tech/md/db/nosql-redis/db-redis-x-cache.html "缓存问题")
4. [3种常用的缓存读写策略](https://snailclimb.gitee.io/javaguide/#/docs/database/Redis/3%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5  "3种常用的缓存读写策略")