---  
title: "JVM运行时数据区（JVM内存结构）"  
date: 2018-05-02
weight: 70  
draft: false  
keywords: [""]  
description: "JVM运行时数据区"  
tags: ["JVM"]
categories: ["JVM"]  
author: "默哥"  

lightgallery: true

toc:
  auto: false
---


## JVM 内存结构
*栈是运行时的单位，而堆是存储的单位。（**栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪**)。*

![](/images/jvm/jvm-jrm.png "JVM运行时数据区")

### 按照线程使用情况和职责分成两大类
#### 线程独享 （程序执行区域）
* 虚拟机栈、本地方法栈、程序计数器
* 不需要垃圾回收
#### 线程共享 （数据存储区域）
* 堆和方法区
* 存储类的静态数据和对象数据
* 需要垃圾回收

## 堆
*Java堆在JVM启动时创建内存区域去实现对象、数组与运行时常量的内存分配，它是虚拟机管理最大的，也是垃圾回收的主要内存区域 。*
### 堆内存划分：
**核心逻辑就是三大假说，基于程序运行情况进行不断的优化设计。**

![](/images/jvm/jvm-heap.png "堆")

### 堆内存为什么会存在新生代和老年代
分代收集理论：当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”（GenerationalCollection）的理论进行设计，**分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法
则**，它建立在两个分代假说之上：
* 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。
* 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。

这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：**收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。**
* 如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；
* 如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域。

这就同时**兼顾了垃圾收集的时间开销和内存的空间有效利用。**

### 内存模型变迁
#### JDK1.7
![](/images/jvm/jvm-jdk17.png "JDK1.7")

* Young 年轻区 ：主要保存年轻对象，分为三部分，Eden区、两个Survivor区。
* Tenured 年老区 ：主要保存年长对象，当对象在Young复制转移一定的次数后，对象就会被转移到Tenured区。
* Perm 永久区 ：主要保存class、method、filed对象，这部份的空间一般不会溢出，除非一次性加载了很多的类，不过在涉及到热部署的应用服务器的时候，有时候会遇到OOM :PermGen space 的错误。
* Virtual区： 最大内存和初始内存的差值，就是Virtual区。

#### JDK1.8
![](/images/jvm/jvm-jdk18.png "JDK1.8")

* 由2部分组成，新生代（Eden + 2*Survivor ） + 年老代（OldGen ）
* JDK1.8中变化最大是，Perm永久区用Metaspace进行了替换
* 注意：Metaspace所占用的内存空间不是在虚拟机内部，而是在本地内存空间中。区别于JDK1.7

#### JDK1.9
![](/images/jvm/jvm-jdk19.png "JDK1.9")

* 取消新生代、老年代的物理划分
* 将堆划分为若干个区域（Region），这些区域中包含了有逻辑上的新生代、老年代区域


为了进行高效的垃圾回收，虚拟机把堆内存逻辑上划分成三块区域（分代的唯一理由就是优化 GC 性能）： 
* 新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代 
* 老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大 
* 元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存

#### 年轻代
年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 Minor GC。年轻一代被分为三个部分——伊甸园（Eden Memory）和两个幸存区（Survivor Memory，被称为from/to或s0/s1），默认比例是8:1:1 
* 大多数新创建的对象都位于 Eden 内存空间中 
* 当 Eden 空间被对象填充时，执行Minor GC，并将所有幸存者对象移动到一个幸存者空间中 
* Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，一个幸存者空间总是空的 
* 经过多次 GC 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代

#### 老年代
旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主GC（Major GC），通常需要更长的时间。 

大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个Survivor 区之间发生大量的内存拷贝
![](/images/jvm/oldheap.jpg "堆内存空间")


## 程序计数器
* 它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域 
* 在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致 
* 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 native 方法，则是未指定值（undefined） 
* 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成 
* 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令 
* 它是唯一一个在 JVM 规范中没有规定任何 OutOfMemoryError 情况的区域

## 虚拟机栈
* 是线程私有的，生命周期和线程一致。
* 主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。
* 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。
* JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着入栈（进栈/压栈），方法执行结束出栈。
* 栈不存在垃圾回收问题。

## 本地方法栈
* Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用 
* 本地方法栈也是线程私有的 
* 允许线程固定或者可动态扩展的内存大小 
  * 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 StackOverflowError 异常 
  * 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java虚拟机将会抛出一个OutofMemoryError异常 
* 本地方法是使用 C 语言实现的 
* 它的具体做法是 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。 
* 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存 
* 并不是所有 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。
* 如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈 
* 在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一


## 元空间&方法区
* **方法区（method area）只是 JVM 规范中定义的一个概念**，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而**永久代（PermGen）是 Hotspot 虚拟机特有的概念， Java8 的时候又被元空间取代了**，永久代和元空间都可以理解为方法区的落地实现。 
* 永久代物理是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 JVM 限制了，也比较难发生OOM（都会有溢出异常） 
* Java7 中我们通过-XX:PermSize 和 -xx:MaxPermSize 来设置永久代参数，Java8 之后，随着永久代的取消，这些参数也就随之失效了，改为通过-XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 用来设置元空间参数 
* 存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中 
* 如果方法区域中的内存不能用于满足分配请求，则 Java 虚拟机抛出 OutOfMemoryError 
* JVM 规范说方法区在逻辑上是堆的一部分，但目前实际上是与 Java 堆分开的（Non-Heap） 

所以对于方法区，Java8 之后的变化： 
* 移除了永久代（PermGen），替换为元空间（Metaspace）； 
* 永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）； 
* 永久代中的 interned Strings 和 class static variables 转移到了 Java heap； 
* 永久代参数 （PermSize MaxPermSize） -> 元空间参数（MetaspaceSize MaxMetaspaceSize

#### 对象在堆中的生命周期
1. 在 JVM 内存模型的堆中，堆被划分为新生代和老年代
  * 新生代又被进一步划分为 Eden区 和 Survivor区，Survivor 区由 From Survivor 和 To Survivor 组成 
2. 当创建一个对象时，对象会被优先分配到新生代的 Eden 区
  * 此时 JVM 会给对象定义一个对象年轻计数器（-XX:MaxTenuringThreshold） 
3. 当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC）
  * JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1 
  * 对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会+1 
4. 如果分配的对象超过了-XX:PetenureSizeThreshold，对象会直接被分配到老年代 

#### 对象的分配过程
为对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法和内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。 
1. new 的对象先放在伊甸园区，此区有大小限制 
2. 当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区 
3. 然后将伊甸园中的剩余对象移动到幸存者 0 区 
4. 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区，如果没有回收，就会放到幸存者 1 区 
5. 如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区 
6. 什么时候才会去养老区呢？ 默认是 15 次回收标记 
7. 在养老区，相对悠闲。当养老区内存不足时，再次触发 Major GC，进行养老区的内存清理 
8. 若养老区执行了 Major GC  之后发现依然无法进行对象的保存，就会产生 OOM 异常
