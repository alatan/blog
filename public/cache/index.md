# 缓存概览


## 缓存问题
> Redis最常用的一个场景就是作为缓存，在实践中可能会有哪些问题？比如一致性, 穿击, 穿透, 雪崩, 污染等。
### 缓存穿透
**缓存穿透是指缓存和数据库中都没有的数据**，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。

在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。

解决方案：
1. 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截； 
2. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用. 。这样可以防止攻击用户反复用同一个id暴力攻击 
3. 布隆过滤器。bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小。

### 缓存击穿
**缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期)**，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。 

解决方案 
1. 设置热点数据永远不过期。 
2. 接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些服务不可用时候，进行熔断，失败快速返回机制。 
3. 加互斥锁.

### 缓存雪崩 
**缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机**。和缓存击穿不同的是，**缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了**，很多数据都查不到从而查数据库。 

解决方案： 
1. 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。 
2. 如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。 
3. 设置热点数据永远不过期。

### 缓存污染（或满了) 
**缓存污染问题说的是缓存中一些只会被访问一次或者几次的的数据，被访问完后，再也不会被访问到，但这部分数据依然留存在缓存中，消耗缓存空间。** 

缓存污染会随着数据的持续增加而逐渐显露，随着服务的不断运行，缓存中会存在大量的永远不会再次被访问的数据。缓存空间是有限的，如果缓存空间满了，再往缓存里写数据时就会有额外开销，影响Redis性能。这部分额外开销主要是指写的时候判断淘汰策略，根据淘汰策略去选择要淘汰的数据，然后进行删除操作。

#### 缓存淘汰策略
* 不淘汰
    * noevictionv4.0后默认的。
* 对设置了过期时间的数据中进行淘汰 
    * 随机：volatile-random
    * ttl：volatile-ttl 越早过期的数据越优先被选择。
    * lru：volatile-lru LRU算法：LRU 算法的全称是 Least Recently Used，按照最近最少使用的原则来筛选数据。这种模式下会使用 LRU 算法筛选设置了过期时间的键值对。
    * lfu：volatile-lfu LFU 算法：LFU 缓存策略是在 LRU 策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。当使用 LFU 策略筛选淘汰数据时，首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出缓存。如果两个数据的访问次数相同，LFU 策略再比较这两个数据的访问时效性，把距离上一次访问时间更久的数据淘汰出缓存。
* 全部数据进行淘汰
    * 随机：allkeys-random
    * lru：allkeys-lru
    * lfu：allkeys-lfu

### 数据库和缓存一致性
#### 方案：队列 + 重试机制
流程如下所示 
* 更新数据库数据； 
* 缓存因为种种问题删除失败 
* 将需要删除的key发送至消息队列 
* 自己消费消息，获得需要删除的key 
* 继续重试删除操作，直到成功 

然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。

#### 方案：异步更新缓存(基于订阅binlog的同步机制)
MySQL binlog增量订阅消费+消息队列+增量数据更新到redis 
1. 读Redis：热数据基本都在Redis 
2. 写MySQL: 增删改都是操作MySQL 
3. 更新Redis数据：MySQL的数据操作binlog，来更新到Redis

读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。 

这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。 

其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。 

这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。

当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis。 

## 参考文章
* [缓存那些事](https://tech.meituan.com/2017/03/17/cache-about.html "缓存那些事")
* [缓存修炼之路](https://mp.weixin.qq.com/s/OhMtHg48MLvkpMzLe88V-g  "缓存修炼之路")
