<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>JVM - 分类 - 软件开发学习记录</title>
        <link>https://moge.fun/categories/jvm/</link>
        <description>JVM - 分类 - 软件开发学习记录</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Wed, 02 May 2018 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://moge.fun/categories/jvm/" rel="self" type="application/rss+xml" /><item>
    <title>JVM类加载器</title>
    <link>https://moge.fun/jvm-classload/</link>
    <pubDate>Wed, 02 May 2018 00:00:00 &#43;0000</pubDate>
    <author>默哥</author>
    <guid>https://moge.fun/jvm-classload/</guid>
    <description><![CDATA[类加载器 启动类加载器(Bootstrap ClassLoader) 负责加载 JAVA_HOME\lib 目录的或通过-Xbootclasspath参数指定路径中的且被虚拟机认可（rt.jar）的类库
扩展类加载器(Extension ClassLoader) 负责加载 JAVA_HOME\lib\ext 目录或通过java.ext.dirs系统变量指定路径中的类库
应用程序类加载器(Application ClassLoader) 负责加载用户路径classpath上的类库
自定义类加载器（User ClassLoader） 加载应用之外的类文件
JVM类加载器执行顺序 检查顺序是自底向上：加载过程中会先检查类是否被已加载，从Custom到BootStrap逐层检查，只要某个类加载器已加载就视为此类已加载，保证此类所有ClassLoader只加载一次 加载的顺序是自顶向下：也就是由上层来逐层尝试加载此类。 加载时机与过程 类加载的四时机： 遇到new、getStatic、putStatic、invokeStatic四条指令时 使用java.lang.reflect包方法时，对类进行反射调用 初始化一个类时，发现其父类还没初始化，要先初始化其父类 当虚拟机启动时，用户需要指定一个主类main，需要先将主类加载 一个类的一生 类的生命周期类加载做了什么？主要做三件事 类全限定名称 → 二进制字节流加载class文件 字节流静态数据 → 方法区（永久代，元空间） 创建字节码Class对象 JVM类加载机制 全盘负责， 当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效 双亲委派机制, 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 类加载途径 jar/war jsp生成的class 数据库中的二进制字节流 网络中的二进制字节流 动态代理生成的二进制字节流 类加载途径双亲委派模型与打破双亲委派 什么是双亲委派？ 当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成加载任务时，才会尝试执行加载任务 为什么需要双亲委派呢？ 主要考虑安全因素，双亲委派可以避免重复加载核心的类，当父类加载器已经加载了该类时，子类加载 器不会再去加载 比如：要加载位于rt.jar包中的类java.lang.Object，不管是哪个加载器加载，最终都委托给顶层的启动 类加载器进行加载，这样就可以保证使用不同的类加载器最终得到的都是同样的Object对象。 为什么还需要破坏双亲委派 在实际应用中，双亲委派解决了Java 基础类统一加载的问题，但是却存在着缺陷。JDK中的基础类作为典型的API被用户调用，但是也存在API调用用户代码的情况，典型的如：SPI代码。这种情况就需要打破双亲委派模式。 数据库驱动DriverManager。以Driver接口为例，Driver接口定义在JDK中，其**实现由各个数据库的服务商来提供，由系统类加载器加载。**这个时候就需要 启动类加载器来委托 子类来加载Driver实现，这就破坏了双亲委派。 如何破坏双亲委派 重写ClassLoader的loadClass方法 在 jdk 1.2 之前，那时候还没有双亲委派模型，不过已经有了 ClassLoader 这个抽象类，所以已经有人继承这个抽象类，重写 loadClass 方法来实现用户自定义类加载器。 而在 1.]]></description>
</item>
<item>
    <title>JVM运行时数据区（JVM内存结构）</title>
    <link>https://moge.fun/jvm-memory/</link>
    <pubDate>Wed, 02 May 2018 00:00:00 &#43;0000</pubDate>
    <author>默哥</author>
    <guid>https://moge.fun/jvm-memory/</guid>
    <description><![CDATA[JVM 内存结构 栈是运行时的单位，而堆是存储的单位。（栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪)。
JVM运行时数据区按照线程使用情况和职责分成两大类 线程独享 （程序执行区域） 虚拟机栈、本地方法栈、程序计数器 不需要垃圾回收 线程共享 （数据存储区域） 堆和方法区 存储类的静态数据和对象数据 需要垃圾回收 堆 Java堆在JVM启动时创建内存区域去实现对象、数组与运行时常量的内存分配，它是虚拟机管理最大的，也是垃圾回收的主要内存区域 。
堆内存划分： 核心逻辑就是三大假说，基于程序运行情况进行不断的优化设计。
堆堆内存为什么会存在新生代和老年代 分代收集理论：当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”（GenerationalCollection）的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法 则，它建立在两个分代假说之上：
弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。 这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。
如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间； 如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域。 这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。
内存模型变迁 JDK1.7 JDK1.7Young 年轻区 ：主要保存年轻对象，分为三部分，Eden区、两个Survivor区。 Tenured 年老区 ：主要保存年长对象，当对象在Young复制转移一定的次数后，对象就会被转移到Tenured区。 Perm 永久区 ：主要保存class、method、filed对象，这部份的空间一般不会溢出，除非一次性加载了很多的类，不过在涉及到热部署的应用服务器的时候，有时候会遇到OOM :PermGen space 的错误。 Virtual区： 最大内存和初始内存的差值，就是Virtual区。 JDK1.8 JDK1.8由2部分组成，新生代（Eden + 2*Survivor ） + 年老代（OldGen ） JDK1.8中变化最大是，Perm永久区用Metaspace进行了替换 注意：Metaspace所占用的内存空间不是在虚拟机内部，而是在本地内存空间中。区别于JDK1.7 JDK1.9 JDK1.9取消新生代、老年代的物理划分 将堆划分为若干个区域（Region），这些区域中包含了有逻辑上的新生代、老年代区域 为了进行高效的垃圾回收，虚拟机把堆内存逻辑上划分成三块区域（分代的唯一理由就是优化 GC 性能）：
新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代 老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大 元空间（JDK1.]]></description>
</item>
<item>
    <title>JVM概览</title>
    <link>https://moge.fun/jvm/</link>
    <pubDate>Tue, 01 May 2018 00:00:00 &#43;0000</pubDate>
    <author>默哥</author>
    <guid>https://moge.fun/jvm/</guid>
    <description><![CDATA[JVM关键知识点 JVM基本常识 类加载系统 运行时数据区（JVM 内存结构） 一个对象的一生（出生、死亡与内涵） GC垃圾收集器 JVM调优相关工具与可调参数 调优实战案例 JVM架构图JVM内存模型(JMM) Java内存模型，其实是保证了Java程序在各种平台下对内存的访问都能够得到一致效果的机制及规范。目的是解决由于多线程通过共享内存进行通信时，存在的原子性、可见性（缓存一致性）以及有序性问题。
并发编程模型的分类 在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。
在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写 - 读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。
同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。
Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的 Java 程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。
Java 内存模型的抽象 JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 java 程序员提供内存可见性保证。
Java 线程之间的通信由 Java 内存模型（本文简称为 JMM）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读 / 写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下： Java内存模型的抽象示意图重排序 在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：
编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。 从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序： JMM指令重排序上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。]]></description>
</item>
</channel>
</rss>
