# Java架构演变历史


***Java网站架构演变过程，大致分为5个阶段，分别为单体架构、集群架构、分布式架构、SOA架构和微服务架构。***

### 单体架构
> 应用、数据库、文件都部署在一台机器上。简单来讲其实就是我们熟知的SSM架构(Spring+SpringMVC+MyBatis)，把所有的业务模块都放在一个应用中开发，这里面又衍生出三层架构，即表示层、业务逻辑层和数据库访问层，虽然在软件设计中划分了经典的三层模型，但是对业务场景没有划分，一个典型的单体应用就是将所有的业务场景的表示层、业务逻辑层和数据访问层放在一个工程项目中，最终经过编译、打包，部署在一台服务器上。

#### 单体架构优点
1. 部署简单: 由于是完整的结构体，可以直接部署在一个服务器上即可。
2. 技术单一: 项目不需要复杂的技术栈，往往一套熟悉的技术栈就可以完成开发。
3. 用人成本低: 单个程序员可以完成业务接口到数据库的整个流程。

#### 单体架构缺点
1. 系统启动慢： 一个进程包含了所有的业务逻辑，涉及到的启动模块过多，导致系统的启动、重启时间周期过长;
2. 系统错误隔离性差、可用性差：任何一个模块的错误均可能造成整个系统的宕机;
3. 可伸缩性差：系统的扩容只能只对这个应用进行扩容，不能做到对某个功能点进行扩容;
4. 线上问题修复周期长：任何一个线上问题修复需要对整个应用系统进行全面升级。

![单体架构](/images/archHistory/single.jpg)

### 集群架构（cluster）
> 不同服务器部署同一套应用程序对外提供服务，实现服务的负载均衡或者互备(热备，主从)。同一种组件的多个实例，形成逻辑上的整体。单个节点可以提供完整服务，集群是物理形态。

#### 集群架构相关技术点
1. 应用和数据分离(大量用户高并发的访问导致系统性能越来越差，数据存储空间开始出现不足)
2. 缓存的使用(QPS持续提高，为了降低接口访问时间、提高服务性能和并发，根据二八定律可以将80%的数据缓存)
3. 负载均衡器的代理服务器
4. 数据库读写分离
5. 反向代理和CDN加速

![集群架构](/images/archHistory/cluster.jpg)

#### 负载平衡
集群就是把一个的事情交给多个人去做，假如要做1000个产品给一个人做要10天，我叫10个人做就是一天，这就是集群，负载均衡的话就是用来控制集群，他把做的最多的人让他慢慢做休息会，把做的最少的人让他加量让他做多点。

### 分布式架构
> 服务的不同模块部署在不同的机器上，单个节点不能提供完整服务，需要多节点协调提供服务(相同组件部署在不同节点，节点间通过交互信息协作提供服务)，分布式强调的是工作方式。

#### 分布式相关技术点
1. 业务分库分表
2. 业务模块拆分成子项目
3. NoSQL和搜索引擎对可伸缩的分布式特性具有更好的支持，应用服务器通过一个统一的数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。

![分布式架构](/images/archHistory/distributed.jpg)

### SOA架构
> 面向服务的设计架构，其中包含多个服务，服务之间通过相互依赖最终提供一系列的功能。一个服务通常以独立的形式存在于操作系统进程中。各个服务之间通过网络调用。

* 中心化实现：**ESB(企业服务总线)**，各服务通过ESB进行交互，解决异构系统之间的连通性，通过协议转换，消息解析，消息路由把服务提供者的数据传送到服务消费者。
* **去中心化实现：微服务**

![SOA架构](/images/archHistory/soa.png)

### 微服务架构(在SOA上做的升华)
> 微服务就是一个独立的职责单一的服务应用程序，微服务架构强调业务需要彻底组件化和服务化，原有的单个业务系统会拆分为多个可独立开发，设计，运行的小应用。这些小应用通过服务完成交互和集成。

#### 优点
* 每个服务直接足够内聚，代码容易理解
* 开发效率高，一个服务只做一件事，适合小团队开发
* 松耦合，有功能意义的服务。
* 可以用不同语言开发，面向接口编程。
* 易于第三方集成
* 微服务只是业务逻辑的代码，不会和HTML,CSS或其他界
* 可以灵活搭配，连接公共库/连接独立库
#### 缺点
* 分布式系统的责任性
* 多服务运维难度加大。
* 系统部署依赖，服务间通信成本，数据一致 ，系统集成测试，性能监控。
* 服务间通信成本
* 数据一致性
* 系统集成测试
* 性能监控

![微服务架构](/images/archHistory/microservice.jpg)

### Service Mesh 架构（集中管理微服务中非业务相关内容，让微服务更加专注于业务处理）
* 最初，流量管理和控制能力（比如图例中的熔断、服务发现）是和业务逻辑耦合在一起，即便以引用包的方式被调用，依然解决不了异构系统无法重用的问题。
* 流控功能和业务耦合相当不美好，于是出现了提供这些功能的公共库和框架。但这些库通常比较复杂，无论是学习使用，与业务系统整合、维护都会带来很大的成本。
* 为避免花费太多时间开发和维护这些通用库，人们希望流量控制能力可以下沉到网络通讯栈的层面，但几乎无法实现。
* 于是另一种思路出现，就是将这些功能独立成一个代理，由它先接管业务服务的流量，处理完成后再转发给业务服务本身，这就是 Sidecar 模式。
* 为统一管理 Sidecar，该模式进一步进化，形成网络拓扑，增加了控制平面，演变成 Service Mesh（最后的网格图中，绿色代表业务服务，蓝色代表 sidecar 服务）。

业务系统的核心价值应该是业务本身，而不是服务，微服务只是一种实现手段，实现业务才是目标。现有的微服务架构下，为解决可能出现的网络通信问题，提升系统的弹性，开发人员不得不花费大量时间和精力去实现流量控制相关的非业务需求，不能聚焦在业务本身。

而 Service Mesh 的出现解决了这一问题，带来了下面 2 个变革：
* 解决了微服务框架中的服务流量管理的痛点，使开发人员专注于业务本身；
* 将服务通信及相关管控功能从业务程序中分离并下层到基础设施层，使其和业务系统完全解耦。

#### 小结
> 解耦是软件开发中永恒的主题，开发人员对消除重复的偏执是推动软件、以及架构模式演进的主要动力。而 Service Mesh 的核心价值就是将服务通信功能从业务逻辑中解耦，并下沉为基础设施，由控制平面统一管理。

有人将 Service Mesh、Kubernetes 和 Serverless 技术称为**云原生应用开发**的三驾马车。
* Kubernetes 是云应用实际意义上的操作系统；
* Service Mesh 将服务通信功能剥离，实现了与业务的解耦；
* Serverless 让你不用关心应用的服务器。
* 这三项技术让我们有能力实现应用开发的终极目标，那就是：只关注业务本身。而它们，也会引领我们通向未来云原生应用的诗和远方。

详细介绍：[Service Mesh 浅析：从概念、产品到实践](https://www.infoq.cn/article/xveohtcortxrspcf2ldd "Service Mesh 浅析：从概念、产品到实践")

## 参考文章
* [大型互联网架构演化简史](https://www.geekhalo.com/2019/09/01/architecture/evolution/)
* [亿级流量高并发是怎么抗住的](https://juejin.cn/post/6844903991336402958)
